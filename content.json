{"pages":[{"title":"about","text":"","link":"/about/index.html"},{"title":"近期规划","text":"","link":"/project/index.html"},{"title":"近期规划","text":"Hexo个人博客 博客基本功能 busuanzi 博客评分机制 文章详情页两栏https://www.alphalxy.com/2019/03/customize-icarus/ Post正文 Markdown语法 Tag Plugins 插入表情 修改字体 博客访问加速 gzip压缩 CDN加速 √ 按照腾讯云提供的教程操作一番即可 域名公安备案 Google Adsense广告位 嵌入Gitbook 菜单栏定制 面试 基础知识 编程语言 操作系统 计算机网络 数据库 数据结构与算法 系统设计题 https://github.com/donnemartin/system-design-primer 《Designing Data-Intensitive Application》 grokking-the-system-design-interview $80 项目相关 其他 宝洁八大问 基础理论知识 Golang b站 21周 数据库 上：关系模式+SQL √ 中：数据建模 下：底层原理 中国大学MOOC 10+6+7周 软件工程 中国大学MOOC 11周 操作系统 √ 计算机网络 中国大学MOOC 9周 分布式系统 MIT经典课程： 教学视频 课件 时间 Golang 数据库 计算机网络 软件工程 分布式系统 4.3 -反射√ 第1章 (上)√ 第1章 √ 4.12 -Redis√ 第2-10章(上)√ 第1章√ 第2章√ 4.19 141-159 第17章(下)√ 第2章√ 4.26 160-180 第18章(下)√ 第3-4章 5.3 181-200 第19-20章(下) 第3章 5.10 201-218 第21章(下) 第5-6章 5.17 第22章(下) 第4章 5.24 第23章(下) 第7章 LEC1 5.31 第5-6章 6.7 第7-9章 第8章 6.14 第10- 第9章 6.21 第10-11章 LEC 2 6.28 LEC 3 7.5 LEC 4 7.12 LEC 5 7.19 LEC 6 7.26 LEC7 LEC 8 LEC 9 LEC 10 LEC 11 LEC 12 :star2: 每周大概10个小时 算法与数据结构 LeetCode1000题+周赛 b站 左神算法进阶 b站 闫学灿直播视频 Acwing 《算法竞赛进阶指南》刷题打卡 Interviewbit geekforgeeks 互联网小工具 Git vim docker Golang","link":"/schedule/index.html"}],"posts":[{"title":"Go语言基础","text":"Go语言基础变量&amp;常量不同于C/C++，Go的变量类型放在变量名之后,以下是常见变量类型的对比 Go C var a int int a; var a *int int* a; var a []int int a[]; var a [][] [] [] int int a[] []; var a []map[int] string vector&lt;map&lt;int,string&gt; &gt; a; var t map[string] []map[string]string map&lt;string,vector&lt;map&lt;int ,string &gt; &gt; &gt; a; Go语言中，类型声明这样设计的哲学据说是为了克服C语言的复杂性。当多个类型嵌套或者使用函数指针类型时，C语言类型变得很复杂，不易懂，Go简化了这一过程 :=的含义也不同于Pascal，在Go语言中，该符号表示声明并赋值，免去var声明过程 123var a inta=100b:=100 常量最常见的用法是使用iota来模拟枚举类型 123456const ( n1 = iota //0 n2 //1 n3 //2 n4 //3 ) 基本数据类型 整型：int|int8、int16、int32、int64|uint8、uint16、uint32、uint64 int类型根据计算机的实际位数在不同电脑有不同的表示 浮点型：float32、float64 布尔型：true、false 字符串：string|byte|rune byte=uint8，适用于英文string；rune=int32，用于包含其他语言的string 12345678s := \"hello world\"for i := 0; i &lt; len(s); i++ { //byte fmt.Printf(\"%v(%c) \", s[i], s[i])}s := \"hello 中国\"for _, r := range s { //rune fmt.Printf(\"%v(%c) \", r, r)} Go语言没有隐式类型转换，只有强制类型转换 123var a int=100var b float64b=float64(a) //int--&gt;double 依然需要强制类型转换 引用类型 数组、切片、map Go语言中函数的参数有两种传递方式，按值传递和按引用传递. Go默认使用按值传递（函数形参为基本数据类型和数组）来传递参数，也就是传递参数的副本。在函数中对副本的值进行更改操作时，不会影响到原来的变量。 12func add(a int,b int)int{}//副本func add(a []int,b int){}//副本 数组经常使用的是指针传递或者传入slice 123456789101112func add(a *[5]int, n int) int { //指向数组的指针 s := 0 for i := 0; i &lt; n; i++ { s += (*a)[i] } (*a)[0] = 10 return s}func main(){ var a [5]int sum:=add(&amp;a,5)//此时a[0]已经发生改变} 引用类型（slice、map、interface、channel）都默认使用引用传递,可以返回参数的改变量 12345func sum(arr []int) int {}func main() { var arr = [5]int{1, 2, 3, 4, 5} fmt.Println(sum(arr[:]))} 数组固定长度 123456for i:=0;i&lt;n;i++{//访问实际的元素 fmt.Println(a[i])}for k,v:=range a{//该方法访问数组的所有元素——Capibility个 fmt.Println(k,v)} slice切片类似于C++中的Vector（Python的list），使用内置的len()函数求长度，使用内置的cap()函数求切片的容量 声明slice 12var a []intvar s []string 不同于数组，此处无需定义数组的容量，slice类型 初始化 1234a:=[]int{1,2,3,4,5}b:=a[1:3]//通过数组获得切片s := make([]int, 2, 10)//通过make获得切片 切片操作 1a[low,high]//a[low≤index&lt;high] 引用传递——同第0节内容，切片可以带回函数变化量 Map对应于C++里面的Map、Python里的Dict，底层是Hash散列实现的数据结构，常见的基本操作有以下几种 定义Map 1234var a map[KeyType]ValueType//声明a=make(map[string]int)s:=make(map[KeyType]ValueType, [cap])//类似指针的new、malloc操作，分配空间 遍历Map 12for k, v := range scoreMap {}//遍历&lt;key,value&gt;for k := range scoreMap {}//遍历key 查询某个Key是否存在 123456v, ok := scoreMap[\"张三\"]if ok {//存在 } else {//不存在 } 添加、修改某个&lt;Key,value&gt; 1m[key]=value 删除某个key 1delete(map, key) 函数与闭包 函数类型（底层应该是函数指针）： 12type calculation func(int, int) intfunc calc(x, y int, op func(int, int) int) int {//函数类型作为形参 闭包：闭包指的是一个函数和与其相关的引用环境组合而成的实体。在函数中不可以声明有名函数，但是可以申明匿名函数，此匿名函数可以共享该函数的外部参数 1234567func adder() func(int) int { var x int return func(y int) int { x += y return x }} adder函数返回的是一个函数类型（C/C++中的函数指针） 为什么要使用闭包？闭包是为了解决什么问题而引入的？ ​ 别人已经写好的函数库中的回调函数只能传入func()的函数类型，但是我们写的函数类型是func(int,int)int，此时如何把这个函数通过参数传入进去 1234567891011121314151617181920func callback(f func()){//别人库中的回调函数 f()}--------------------------------func myfunc(x,y int){//个人实现的功能性函数 fmt.Println(x+y)}//该函数负责转换，将函数类型转化成callback函数可以接受的类型func convert(f func(int,int),x int,y int)func(){//f,x,y变量可以在匿名函数中访问 return func(){ f(x,y) }}func main(){ x:=1 y:=2 newf:=convert(myfunc,x,y) callback(newf)} Tips: convert函数：func(int,int)int–&gt;func() 执行callback(newf)其实就是在执行f(x,y)，x和y变量已经被提前注入了 defer Go语言中的defer语句会将其后面跟随的语句进行延迟处理。在defer归属的函数即将返回时，将延迟处理的语句按defer定义的逆序进行执行，也就是说，先被defer的语句最后被执行，最后被defer的语句，最先被执行。 由于defer语句延迟调用的特性，所以defer语句能非常方便的处理资源释放问题。比如：资源清理、文件关闭、解锁及记录时间等。 反射 给出一个变量，利用反射机制可以得到该该变量的元数据信息，最简单的元数据就是数据类型 reflect包提供了reflect.TypeOf和reflect.ValueOf两个函数来获取任意对象的Value和Type. 123456789101112131415161718192021222324type student struct { Name string `json:\"name\"` Score int `json:\"score\"`}func main() { stu1 := student{ Name: \"小王子\", Score: 90, } t := reflect.TypeOf(stu1) fmt.Println(t.Name(), t.Kind()) // student struct // 通过for循环遍历结构体的所有字段信息 for i := 0; i &lt; t.NumField(); i++ { field := t.Field(i) fmt.Printf(\"name:%s index:%d type:%v json tag:%v\\n\", field.Name, field.Index, field.Type, field.Tag.Get(\"json\")) } // 通过字段名获取指定结构体字段信息 if scoreField, ok := t.FieldByName(\"Score\"); ok { fmt.Printf(\"name:%s index:%d type:%v json tag:%v\\n\", scoreField.Name, scoreField.Index, scoreField.Type, scoreField.Tag.Get(\"json\")) }} 反射机制的典型应用： Json格式与struct的相互转换 1234567891011121314151617181920//Student 学生type Student struct { ID int Gender string Name string}//Class 班级type Class struct { Title string Students []*Student}str := `{\"Title\":\"101\",\"Students\":[{\"ID\":0,\"Gender\":\"男\",\"Name\":\"stu00\"},{\"ID\":1,\"Gender\":\"男\",\"Name\":\"stu01\"},{\"ID\":2,\"Gender\":\"男\",\"Name\":\"stu02\"},{\"ID\":3,\"Gender\":\"男\",\"Name\":\"stu03\"},{\"ID\":4,\"Gender\":\"男\",\"Name\":\"stu04\"},{\"ID\":5,\"Gender\":\"男\",\"Name\":\"stu05\"},{\"ID\":6,\"Gender\":\"男\",\"Name\":\"stu06\"},{\"ID\":7,\"Gender\":\"男\",\"Name\":\"stu07\"},{\"ID\":8,\"Gender\":\"男\",\"Name\":\"stu08\"},{\"ID\":9,\"Gender\":\"男\",\"Name\":\"stu09\"}]}`c1 := &amp;Class{}err = json.Unmarshal([]byte(str), c1)if err != nil { fmt.Println(\"json unmarshal failed!\") return}fmt.Printf(\"%#v\\n\", c1) 编写Unmarshal函数的的库程序员只能获取c1变量，利用反射机制推断出其对应的struct结构 Ini配置文件读入到struct 并发协程​ 协程(goroutine)是一个比线程还要轻量级的用户态线程，我们可以根据需要创建成千上万个goroutine并发工作。 其他语言的线程都是创建在内核态线程？？？ ​ OS线程（操作系统线程）一般都有固定的栈内存（通常为2MB）,一个goroutine的栈在其生命周期开始时只有很小的栈（典型情况下2KB），goroutine的栈不是固定的，他可以按需增大和缩小，goroutine的栈大小限制可以达到1GB，虽然极少会用到这个大。所以在Go语言中一次创建十万左右的goroutine也是可以的。 ​ GPM是Go语言运行时（runtime）层面的实现，是go语言自己实现的一套调度系统。单从线程调度讲，Go语言相比起其他语言的优势在于OS线程是由OS内核来调度的，goroutine则是由Go运行时（runtime）自己的调度器调度的，这个调度器使用一个称为m:n调度的技术（复用/调度m个goroutine到n个OS线程）。 创建goroutine 1234567891011121314151617181920212223242526272829var wg sync.WaitGroupfunc func1(out &lt;-chan int,in chan&lt;- int){//只能从chan取数,不可写入 defer wg.Done()//协程数-1 for { i, ok := &lt;-ch1 // 通道关闭后再取值ok=false if !ok { break } ch2 &lt;- i * i } close(in) close(out)}func main(){ var in chan int var out chan int in=make(chan int,100) out=make(chan int,100) for i=0;i&lt;100;i++{ out&lt;-i//主协程写入数据 } wg.Add(1)//协程数+1 go func1(out,in)//启动协程 wg.Wait()//等待所有协程结束} go func(parm)参数直接通过形参传入协程 协程间通信 协程间数据通信存在两种方式，channel和共享全局变量 channel 三种基本操作：发送、接收、关闭 123ch&lt;-x//发送x:=&lt;-ch//接收close(ch)//关闭 两种模式：无缓冲channel和有缓冲channel 12ch := make(chan int)ch := make(chan int, 10) // 创建一个容量为1的有缓冲区通道 无缓冲通道上的发送操作会阻塞，直到另一个goroutine在该通道上执行接收操作，这时值才能发送成功，两个goroutine将继续执行。相反，如果接收操作先执行，接收方的goroutine将阻塞，直到另一个goroutine在该通道上发送一个值。 有缓冲的channel，当缓冲区满即阻塞，等待别的协程把数据取出 最常用的方式 ​ g1协程写入数据到c1 channel中，可以开启多个goroutine通过读取c1的数据，并行处理c1的数据，处理后的数据存入c2 channel 共享全局变量 互斥锁 互斥锁本质上是一种特殊的信号量，资源数量为1 123456var lock sync.Mutexlock.Lock()XXXXXXXXXXXlock.Unlock() 读写锁 g1协程读取的时候，别的协程依然可以读取；g1协程写入的时候，拥有对资源的绝对使用权，别的协程不能读取和写入 123456789rwlock sync.RWMutexrwlock.RLock()读取共享变量rwlock.RUnlock()rwlock.Lock()写入共享变量rwlock.Unlock() sync.Once 用于在多个goroutine中只能执行一次的函数，内部通过mutex互斥锁实现 典型应用场景：例如只加载一次配置文件、只关闭一次通道等 1234567var loadIconsOnce sync.Oncefunc f(){//自定义需要执行的函数 }loadIconsOnce.Do(f) sync.Map Go语言中内置的map不是并发安全的,因此需要使用sync.Map sync.Map内置了诸如Store、Load、LoadOrStore、Delete、Range等操作方法,使用方法类似，仅仅是换了一个函数名 12345678910111213141516var m = sync.Map{}func main() { wg := sync.WaitGroup{} for i := 0; i &lt; 20; i++ { wg.Add(1) go func(n int) { key := strconv.Itoa(n) m.Store(key, n) value, _ := m.Load(key) fmt.Printf(\"k=:%v,v:=%v\\n\", key, value) wg.Done() }(i) } wg.Wait()} 原子操作 ​ x++命令内部实现需要三个步骤，因此在某一个线程执行该命令时，可能被其它线程打断，造成无可预料的错误，这就是说该命令不是原子的。sync/atomic包提供了很多原子操作的方法，里面的函数在执行时都会在一个机器指令周期完成， 不会被别的协程打断保证命令的原子性。类似TestAndSet，个人估计原子操作函数内部可能通过关闭中断实现 123import \"\"sync/atomic\"\"atomic.AddInt64(&amp;x, 1) 网络编程（net库） Socket编程 golang的socket编程比C++简化了很多 实现TCP协议 server 123456789101112131415161718192021222324252627282930313233343536// tcp/server/main.go// TCP server端// 处理函数func process(conn net.Conn) { defer conn.Close() // 关闭连接 for { reader := bufio.NewReader(conn) var buf [128]byte n, err := reader.Read(buf[:]) // 读取数据 if err != nil { fmt.Println(\"read from client failed, err:\", err) break } recvStr := string(buf[:n]) fmt.Println(\"收到client端发来的数据：\", recvStr) conn.Write([]byte(recvStr)) // 发送数据 }}func main() { listen, err := net.Listen(\"tcp\", \"127.0.0.1:20000\") if err != nil { fmt.Println(\"listen failed, err:\", err) return } for { conn, err := listen.Accept() // 建立连接 if err != nil { fmt.Println(\"accept failed, err:\", err) continue } go process(conn) // 启动一个goroutine处理连接 }} 流程：Listen–&gt;Accept(三次握手)–&gt;Read–&gt;Close ​ Accept获得的conn为client句柄，包含client的信息。server读取数据的时候把conn网口当做是file类型，reader := bufio.NewReader(conn) client 123456789101112131415161718192021222324252627282930// tcp/client/main.go// 客户端func main() { conn, err := net.Dial(\"tcp\", \"127.0.0.1:20000\") if err != nil { fmt.Println(\"err :\", err) return } defer conn.Close() // 关闭连接 inputReader := bufio.NewReader(os.Stdin) for { input, _ := inputReader.ReadString('\\n') // 读取用户输入 inputInfo := strings.Trim(input, \"\\r\\n\") if strings.ToUpper(inputInfo) == \"Q\" { // 如果输入q就退出 return } _, err = conn.Write([]byte(inputInfo)) // 发送数据 if err != nil { return } buf := [512]byte{} n, err := conn.Read(buf[:]) if err != nil { fmt.Println(\"recv failed, err:\", err) return } fmt.Println(string(buf[:n])) }} Dial–&gt;Write–&gt;Close 实现UDP协议 Server 12345678910111213141516171819202122232425262728// UDP/server/main.go// UDP server端func main() { listen, err := net.ListenUDP(\"udp\", &amp;net.UDPAddr{ IP: net.IPv4(0, 0, 0, 0), Port: 30000, }) if err != nil { fmt.Println(\"listen failed, err:\", err) return } defer listen.Close() for { var data [1024]byte n, addr, err := listen.ReadFromUDP(data[:]) // 接收数据,n:数据长度，addr：客户端句柄 if err != nil { fmt.Println(\"read udp failed, err:\", err) continue } fmt.Printf(\"data:%v addr:%v count:%v\\n\", string(data[:n]), addr, n) _, err = listen.WriteToUDP(data[:n], addr) // 发送数据 if err != nil { fmt.Println(\"write to udp failed, err:\", err) continue } }} 流程：ListenUDP–&gt;ReadFromUDP–&gt;Close 没有Accept三次握手连接的过程 Client 1234567891011121314151617181920212223242526// UDP 客户端func main() { socket, err := net.DialUDP(\"udp\", nil, &amp;net.UDPAddr{ IP: net.IPv4(0, 0, 0, 0), Port: 30000, }) if err != nil { fmt.Println(\"连接服务端失败，err:\", err) return } defer socket.Close() sendData := []byte(\"Hello server\") _, err = socket.Write(sendData) // 发送数据 if err != nil { fmt.Println(\"发送数据失败，err:\", err) return } data := make([]byte, 4096) n, remoteAddr, err := socket.ReadFromUDP(data) // 接收数据 if err != nil { fmt.Println(\"接收数据失败，err:\", err) return } fmt.Printf(\"recv:%v addr:%v count:%v\\n\", string(data[:n]), remoteAddr, n)} 流程：DialUDP–&gt;Write–&gt;Close 此处有一个问题：client发送数据后立马就接收数据，n, remoteAddr, err := socket.ReadFromUDP(data) Http服务器​ net/http提供了http协议的相关API，该库应该是建立在socket库net之上，进一步封装，实现http协议。利用socket编程也可以在定义消息实现http协议的，但是该方案需要自己封装帧，稳定性等方面也不如go提供的原生态net/http。 ​ 实际开发中，大部分时间应该在用框架，如何gin进行业务系统的开发，这种原生态的自己编写socket或者http协议的代码仅用作学习使用 get请求 1234567891011121314func main() { resp, err := http.Get(\"https://www.liwenzhou.com/\") if err != nil { fmt.Println(\"get failed, err:\", err) return } defer resp.Body.Close() body, err := ioutil.ReadAll(resp.Body) if err != nil { fmt.Println(\"read from resp.Body failed,err:\", err) return } fmt.Print(string(body))} resp是get请求返回的内容，利用ioutil.ReadAll读取所有对象 server 123456789101112func sayHello(w http.ResponseWriter, r *http.Request) { fmt.Fprintln(w, \"Hello 沙河！\")}func main() { http.HandleFunc(\"/\", sayHello) err := http.ListenAndServe(\":9090\", nil) if err != nil { fmt.Printf(\"http server failed, err:%v\\n\", err) return }} ​ server监听某个路径（如/login），传入某个函数类型，指定处理函数handle。函数传入固定的参数类型w http.ResponseWriter, r *http.Request,gin等go框架应该会对该功能进一步细化。 常用标准库文件相关 OS包 打开文件 1file, err := os.Open(fileName) 返回文件对象句柄 关闭文件 1file.Close() 重命名文件 1os.Rename(oldName,newName) 常见的Linux文件命令，都可以在os包中找到，如mkdir()、Remove()、Chown() 文件IO操作：fmt &amp; bufio &amp; io/ioutil12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879package mainimport ( \"bufio\" \"fmt\" \"io\" \"io/ioutil\" \"os\")var fileName string = \"./1.txt\" // ./表示当前目录//ReadByFile :利用*file类型读取，读取固定长度的内容func ReadByFile(fileName string) { file, err := os.Open(fileName) if err != nil { fmt.Println(\"Open file failed,the error message is:\", err) return } defer file.Close() b := make([]byte, 10) //10个10个读 for { len, err := file.Read(b) if err == io.EOF { fmt.Print(string(b[:len])) return } if err != nil { fmt.Println(\"Read Failed ,the error message is:\", err) return } fmt.Print(string(b[:len])) }}//ReadByBufio 通过bufio包读，一行一行读取。func ReadByBufio(fileName string) { file, err := os.Open(fileName) if err != nil { fmt.Println(\"Open file failed,the error message is:\", err) return } defer file.Close() reader := bufio.NewReader(file) for { str, err := reader.ReadString('\\n')//不适用readLine函数 if err == io.EOF { if len(str) != 0 { fmt.Print(str) } break } if err != nil { fmt.Println(\"reader readline failed,the error message is:\", err) return } fmt.Print(str) }}//ReadByIoutil 通过Ioutil读取文件所有数据func ReadByIoutil(fileName string) { data, err := ioutil.ReadFile(fileName)//该包不需要os.file操作 if err != nil { fmt.Println(\"ioutil read failed,the error message is:\", err) return } fmt.Print(string(data))}func main() { ReadByFile(fileName) fmt.Println(\"\\n\") ReadByBufio(fileName) fmt.Println(\"\\n\") ReadByIoutil(fileName)} 字符串操作：strings &amp; strconv数学计算Go操作Web组件后端框架Gin数据库MySQLRedis 为何要有Redis ​ Redis是一个&lt;key,value&gt;形式的内存数据库，基本的功能是当做一个缓存使用。如果要实现一个缓冲，朴素的思想，在程序中简单使用一个Map或者其他数据存储数据即可，为什么还要使用Redis呢？ 原因：Redis除了基本的数据存储外，还提供事务机制、数据备份和恢复、安全性保证、性能测试等多个功能，保证程序的高可用性。可以把Redis当做一个高可用的整体系统，很多高并发、安全、数据备份等功能该系统已经帮我们完成了，不需要自己再重新实现了。从这点来考虑，就类似于数据库系统，简单的文件系统也可以实现持久化存储功能，为什么还要使用数据库呢？除了数据库SQL简洁方便外，还因为数据库提供了安全性、高并发、数据恢复、原子性等多个原因。后端主要就是解决这些性能问题，如果只是实现基本功能后端程序完全可以很简单，就是因为有个各种性能要求才会变得更加复杂 ​ Redis系统采用c/s模式，包括redis-server和redis-client，同时对外暴露接口，供CMD命令行或者各种语言API调用。通过ping的方式可以判断是否建立client和server之间的通道连接 ​ Redis目前在互联网各个领域已经取代了古老的Memcached Redis中value的数据类型和使用方法 Redis是键值对数据库，value的数据类型常见的有以下5种： string、Hash、List、Set、Sorted Set string bash命令 1234set key valueget keydel keyExist key go命令 123456789101112131415161718192021222324func redisExample() { err := rdb.Set(\"score\", 100, 0).Err() if err != nil { fmt.Printf(\"set score failed, err:%v\\n\", err) return } val, err := rdb.Get(\"score\").Result() if err != nil { fmt.Printf(\"get score failed, err:%v\\n\", err) return } fmt.Println(\"score\", val) val2, err := rdb.Get(\"name\").Result() if err == redis.Nil { fmt.Println(\"name does not exist\") } else if err != nil { fmt.Printf(\"get name failed, err:%v\\n\", err) return } else { fmt.Println(\"name\", val2) }} go语言API的函数名称基本与命令行的命令名称类似 hash 1234HMSET key field1 value1 [field2 value2 ] HSET key field value HGET key field HGETALL key List 1234LPUSH key value1 [value2] //左侧插入RPUSH key value1 [value2] //右侧插入LPUSHX key value //左侧插入一个RPOP key //右侧pop Set 12SADD key member1 [member2] //添加元素SMEMBERS key //返回所有成员 Sorted Set(zset) 123ZADD key score1 member1 [score2 member2] //添加多个成员和分数ZINCRBY key increment member //key的member成员score+increment查询过程有多个多种函数 有序集合的成员是唯一的,但分数(score)却可以重复。每个元素都会关联一个double类型的分数,redis正是通过分数来为集合中的成员进行从小到大的排序。 Redis典型应用场景 缓存系统，减轻主数据库（MySQL）的压力。 计数场景，比如微博、抖音中的关注数和粉丝数。 热门排行榜，需要排序的场景特别适合使用ZSET。 利用LIST可以实现队列的功能。 String(字符串) 二进制安全 可以包含任何数据,比如jpg图片或者序列化的对象,一个键最大能存储512M — Hash(字典) 键值对集合,即编程语言中的Map类型 适合存储对象,并且可以像数据库中update一个属性一样只修改某一项属性值(Memcached中需要取出整个字符串反序列化成对象修改完再序列化存回去) 存储、读取、修改用户属性 List(列表) 链表(双向链表) 增删快,提供了操作某一段元素的API 1,最新消息排行等功能(比如朋友圈的时间线) 2,消息队列 Set(集合) 哈希表实现,元素不重复 1、添加、删除,查找的复杂度都是O(1) 2、为集合提供了求交集、并集、差集等操作 1、共同好友 2、利用唯一性,统计访问网站的所有独立ip 3、好友推荐时,根据tag求交集,大于某个阈值就可以推荐 Sorted Set(有序集合) 将Set中的元素增加一个权重参数score,元素按score有序排列 数据插入集合时,已经进行天然排序 1、排行榜 2、带权重的消息队列 Golang操作Redis的方法（MySQL也是类似的方法） 在PC机上安装Redis，通过命令行工具测试是否安装成功 利用CMD工具打开redis-client，可以直接对Redis进行操作，类似MySQL数据库 在Golang中安装第三方Redis库，使用go get命令 在Golang程序中编写代码，连接Redis并控制 待研究内容： Redis内部原理——解决的主要问题，研究大的方向类似数据库 分布式Redis Redis持久化存储 Redis实践 Redis Reference MongoDBWeb中间件rRPCGo实际项目Ini配置文件解析（反射机制） 为什么使用反射机制 ​ 之所以该功能需要利用反射的原因在于并不知道传入的结构体变量x的具体类型和字段名是什么，因此只能利用反射。该解析ini解析函数相当于底层库，是一个通用函数，供上层程序员调用。如果该ini解析函数库与调用该函数的程序员属于同一个人，那么就可以知道struc的具体结构了，就可以有更加简单的写法，也不用使用反射机制。 思路 ​ 具体来说：从ini文件中每读入一行进行判断，判断是空行、标题、字段、非法行。如果是有效字段，就进行分割成key和value，利用反射机制在x的struct中遍历字段，看是否有某个字段的tag和key相同，然后将该字段的值赋值成value。 日志库 需求分析 定义6种日志级别：Debug、Trace、Info、Warning、Error、Fatal 为了实现功能3，定义日志Level类型（枚举类型）， 123456789101112131415type LogLevel uint32const { DEBUG LogLevel iota TRACE INFO WARNING ERROR FATAL}//log调用方法func testLog(){ log.Debug(\"This is a debug log\") log.Warning(\"This is a warning log\") log.Error(\"This is a error log\")} 日志内容包括：时间、日志级别、文件名、调用函数名、行号、日志信息 时间通过time库实现 runtime.caller(skip int) 文件名、调用函数名、行号 定制阈值level，大于level级别的日志方才输出 123func (f *ConsoleLogger)Debug(msg string){ Debug&gt;=f.level时才输出日志} 定制开关，支持输出到console和文件 Logger包 ​ Logger 接口 ​ Debug()、Trace()、Info()…… ​ ConsoleLogger类 ​ Debug()、Trace()、Info()……NewConsoleLogger()、check() ​ FileLogger类 ​ Debug()、Trace()、Info()……NewFileLogger()、check() Main包 ​ ConsoleLogger类 123type ConsoleLogger struct{ level LogLevel //阈值level} FileLogger类 12345678type ConsoleLogger struct{ level LogLevel //阈值level filePath string //日志路径 fileName string //日志名称 fileobj *os.file //日志文件对象 fileobjerr *os.file //错误级别以上日志对象 maxSize int64 //最大文件大小} 日志切割，根据文件大小或者时间进行切割 每次写入日志前判断一下当前日志文件大小fileobj.stat().size(),小于阈值直接写入，大于该阈值则重新命名日志文件xx.log.bak20200320，并重新打开日志文件写入。 待研究内容Redis ReferenceGo API中文文档 Go与C语言对比 李文周Go语言技术博客","link":"/2020/04/01/Go%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80/"},{"title":"Docker","text":"Docker使用方法 本节重点讲一下Docker是怎么使用的，介绍一些最基本的常见的命令 Docker类似于虚拟机，但相对于虚拟机其具有两大显著特点：更加轻量级，比虚拟机启动跟快；一个宿主机上所能容纳的docker更多。 通过docker search命令搜索可用镜像，docker pull从远程Hub上下载镜像到本机上，docker run可以将镜像运行到容器，docker exec进入容器。容器内部和Linux虚拟机类似，经过修改过的容器，可以通过docker commit修改镜像保存，下次重新加载此镜像就是经过修改后的结果。另外一种制作镜像的方法是通过Dockerfile，通过特定的语法规则定义。 docker内部原理 Dockre是通过go语言实现的容器，熟悉Docker用法之后，下一步就是学习Docker内部是如何实现的，这个以后有时间再慢慢学习","link":"/2020/03/27/Docker/"},{"title":"Hexo框架Icarus主题的基本配置","text":"themelogo图标制作在线favicon制作工具 header header主要包括logo图标、菜单栏和小链接 logo图标可以通过下边两个网址制作，一个logo图标通常由小图标+文字组成阿里巴巴矢量图工具在线svg制作logo工具 添加菜单栏目录的方法： 假如我们要添加一个叫”专题”的菜单栏，步骤如下： 在根目录下新建post，名称叫project 1hexo new post project 此时自动在source目录下生成/project文件夹，里面有一个index.html，就是project菜单栏的默认显示内容。 在主题配置文件_config.yml中加入该菜单 _config.yml12345678910navbar: # Navigation bar menu links menu: 主页: /+ 专题: /project 计划: /schedule 时光轴: /archives 分类: /categories 标签: /tags 关于我: /about sidebar自定义侧边栏的方法： 在F:\\hexo\\blog\\themes\\icarus\\layout\\widget目录下保存的就是默认的widget侧边栏，用户可以在此目录下新建ejs和js文件 然后在主题配置文件_config.yml将该widget显示出来 _config.yml123widgets:+ type: bulletin+ position: right footerMarkdownCode风格库 postpost配置的内容包括以下几个方面： donate：Alipay、WeChatPay comment：Valid share：BaiduShare analysis：busuanzi 参考博客官网GitHub：https://github.com/ppoffice/hexo-theme-icarus/issues?utf8=%E2%9C%93&amp;q=%E4%BB%A3%E7%A0%81https://dp2px.com/ 该作者的GitHub源码：https://github.com/lxqxsyu/hexo-theme-icarushttps://removeif.github.io/ 该作者的GitHub源码：https://github.com/removeif/hexo-theme-icarus-removeif","link":"/2020/03/02/Hexo%E6%A1%86%E6%9E%B6Icarus%E4%B8%BB%E9%A2%98%E7%9A%84%E5%9F%BA%E6%9C%AC%E9%85%8D%E7%BD%AE/"},{"title":"Hexo框架Next主题的基本配置","text":"修改主题 1$ git clone XX 在站点配置的_config.yml中修改theme:next Markdown基本语法Hexo Markdown基本语法在Hexo中渲染MathJax数学公式hexo 本地图片不显示 网站配置 菜单(Menu)添加分类和标签 搜索功能Hexo博客NexT主题美化之搜索服务 评论(comment)valine评论系统不显示浏览器版本和操作系统版本 自定义头部区域背景图http://www.guide2it.com/post/2019-03-05-01-configure-site-according-yourself/ 通用配置Hexo Next主题常见功能配置Hexo 搭建个人博客系列：进阶设置篇 参考网址小图标库代码样式库几个好用的hexo主题Hexo 好看的主题推荐hexo搭建个人博客 htmljavascipt","link":"/2020/03/02/Hexo%E6%A1%86%E6%9E%B6Next%E4%B8%BB%E9%A2%98%E7%9A%84%E5%9F%BA%E6%9C%AC%E9%85%8D%E7%BD%AE/"},{"title":"Git命令","text":"Git常用基本功能git init, git add 和git commit 都是前期的准备, 相当于将你本地的文件都上传到了本地仓库，但是还没有像远端仓库提交； 123456789101112git init //初始化一个git的本地仓库git add README.md //将我的文件装上武器，准备发射git commit -m “first commit” //第一次发射，我的README.md 宝贝已经成功进入到本地仓库git remote add Ceres your_first_git_address //将第一个git address命名为Ceresgit push -u Ceres master //注意咯，我要向远端木星发射了，太远了，一定要用push，很费劲的赶脚 //这时，不要动，准备再次将我的README宝贝发射到火星上去，//但是因为我的文件已经存在与本地仓库了，因此我就不需要再多余地commit等，//只需要将另一个远端仓库与本地仓库建立一个连接就可以了git remote add Mars your_second_git_address //将第二个git address命名为Marsgit push -u Mars master //再次发射，目标火星上的master分支 至此，就将一份代码上传到了两个远端仓库，但是注意你仍然时只有一个本地仓库哦 Git本地化操作 Git本地化操作就是解决Working Directory、Stage、Local Repository三者之间的各种版本回退问题 参考文章：图解git Git 的本地化操作主要集中在以下几个命令，每个命令都有一个常见的语法，细则的话则有很多，实际使用时查阅手册即可： git add git commit git reset git checkout git diff git status git log Git 分支 git branch:新建分支 git checkout :切换分支 git switch git merge git rebase:另外一种合并方式 Git 远程操作常见命令： git bare:自建使用SSH协议的Git仓库，通过git remote add命令即可添加 git push git fetch git merge git pull=(git fetch+ git merge) Git更新远程仓库代码到本地 当我们在多台电脑上或者多人共同开发一个项目的时候，远程仓库会不时地被修改，而自己也在不断修改自己的本地仓库，因此仓库的远程版本与本地版本势必会导致不一致 参考文章 方法一：本地master分支更新至远程主机的master分支 12345git remote -v //查看远程仓库git fetch origin master:tmp //拉取远程origin的master分支到本地tmp分支git diff //比较本地master分支和tmp分支git merge temp //合并本地master分支和tmp分支git branch -d tmp //删除临时的tmp分支 方法二：拉取远程dev分支与本地dev分支合并 1git pull origin dev:dev git pull &lt;远程仓库名&gt; &lt;远程分支名&gt;:&lt;本地分支名&gt; git pull &lt;远程仓库名&gt; &lt;远程分支名&gt; 没有本地分支时，默认是当前分支 git pull &lt;远程仓库名&gt; 上述命令进一步简化成：当前分支关联的远程分支 上述命令等同于 123git fetch origin devgit checkout devgit merge origin/dev Git团队协作 有以下三种常见的团队协作方式 方案一 代码只能由核心开发人员提交，Linux系统开发运作模式 方案二 从远程仓库复制一份到自己的GitHub，然后git clone到本地仓库，git push后通过pull request向远程仓库请求。该方法可以对提交的代码进行review，提出宝贵意见，经过创始人审核同意后方可加入代码库。 方案三 该方案适合小团队并行开发，云端维护master、dev分支，master分支是稳定的发布版本，经过测试完美通过的代码才能合并到该分支。每个开发人员克隆devg分支到本地后，开发各自的feature/feature1分支，经过自测成功后的代码合并到dev分支。然后创建release分支进行多功能联合测试，测试通过后同步到master和dev分支，并在master分支加入tag。如果在master分支出现bug，创建hotfix分支，修改bug后通过到master分支和dev分支。 A successful Git branching model Referencehttps://blog.csdn.net/qq_25458977/article/details/87875641廖雪峰博客https://github.com/521xueweihan/git-tipsgit - 简明指南图解git","link":"/2020/03/02/Git%E5%91%BD%E4%BB%A4/"},{"title":"大数据技术","text":"大数据知识总结","link":"/2020/04/11/%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%8A%80%E6%9C%AF/"},{"title":"Hexo个人博客的安装与部署","text":"摘要：本文主要介绍Hexo博客的安装和部署流程，安装章节包括依赖环境的install和Hexo的基本命令;部署章节包括GitHub和vps的部署。此外还介绍服务器和域名的购买流程。 Hexo 安装（本地）基本配置环境 Git 安装 Node.js安装 Hexo安装12$ npm install -g cnpm --registry=https://registry.npm.taobao.org #切换淘宝镜像$ cnpm install hexo-cli -g #安装hexo Hexo基本命令 初始化站点 1$ hexo init 新建博文 1$ hexo new \"My New Post\" More info: Writing 清空本地静态文件 1$ hexo clean 生成静态文件 1$ hexo generate More info: Generating 启动本地服务器 1$ hexo server More info: Server 部署到远程网站 12$ cnpm install hexo-deployer-git --save #安装deployer包$ hexo deploy #部署到GitHub More info: Deployment 博客的远程部署(自建VPS服务器) Github服务器在国外，主要的优点是免费，但是在国内访问的速度很慢，尤其在手机端更甚，因此需要把Hexo生成的静态网页部署到国内的服务器上。一种简单的方法是把代码部署到Coding网站，但是经过测试依然很慢，于是就在腾讯云购买了服务器和域名，把代码发布到自己的VPS服务器上。 服务器购买新型冠状病毒肆虐期间，腾讯云搞大促互动，遂购买腾讯云一年的服务器。其基本配置是：内存2GB，硬盘50GB，99元/年，价钱可以说是非常良心了。购买的过程比较简单，就跟在淘宝上买东西一样，简单操作一下就好。 腾讯云服务器用户手册 域名购买 域名查询及购买 国内云厂商 可以在阿里云、腾讯云、华为云购买域名，大多云厂商均提供域名购买代理功能。阿里云万网域名查询腾讯云域名查询腾讯云域名查询国内的几家价钱都差不多，第一年可以略有差别，三年和五年的域名购买价钱基本相当。 国外 国外的相对来说域名便宜一点一个可以查询国外各个厂家域名价格，并给出最便宜建议的网站https://www.domcomp.com/GoDaddy：1&amp;1：这两家貌似很便宜namecheap：https://www.namecheap.com/ 因为我的服务器是在腾讯云买的，域名国内的话价钱都差不多，为了方便后边的各项配置，于是在腾讯云购买了域名boya.wiki 域名基本配置购买了域名之后大概要干以下几件事： 配置DNS服务器 将域名映射到ip地址，dns解析一般有两种方式：A和CNAME。A方式就是将域名映射到某个ip，CNAME方式将域名映射到另外一个域名。 实名认证：按照腾讯云给出的提示一步一步操作 域名备案 ICP备案备案和实名认证是两个东西(之前一直认为是一个东西……)，备案的话首先需要用户提交材料，上传到腾讯云审核，然后上传国家相关机构审核。这个就和申请专利类似，腾讯其实是一个代理的作用，如果个体提交的信息有误，腾讯云的客服会帮助个体进行相关信息的修改，以达到快速实现域名的备案。一般实名认证3天后可以开始申请域名备案(个人信息上传到国家系统有延迟)，个体提交备案材料1天后腾讯云即审核通过，如果没有问题的话，一周之内国家也会审核通过的。 公安备案ICP备案成功后访问域名即可以解析到对应的ip地址，最后还需要公安部备案。 🌟远程部署 通常我们把文件上传到GitHub上，默认的repository存储在GitHub提供的免费服务器上。利用SSH协议，我们可以在自建VPS服务器上自建git仓库，实现代码的自动部署。 有三种方法可以实现服务器端的部署方法一：在服务器端重新实现一遍本地部署的方法，安装git、nodejs、hexo 方法二：本地部署到GitHub，然后再服务器端git clone或者git pull 方法三：在服务器端自建repository，本地与服务器端通过SSH直接通信 Hexo个人博客的远程部署原理如下图所示，本地Markdown文件经过渲染后生成html静态文件(一般无数据库后端)，传统的发布到GitHub，本质就是将这些html文件传输到GitHub的远程仓库xxx.github.io。远程部署需要在vps服务器创建git仓库(git bare仓库)，然后利用git-hooks工具自动将git仓库中的代码拷贝到网站的根目录;client访问Hexo博客时通过nginx服务器监听80端口，展示网站根目录的index.html，从而开启网站浏览。 经过本地发布(localhost:4000)和Github发布(xxx.github.io)成功后，将Hexo博客部署到腾讯云VPS上，具体步骤如下： 安装git并配置SSH Tips：安装Git、新建git用户、SSH免密 安装git 123yum update -y #更新yumyum install git # 安装gitgit --version #查看git版本 创建git用户 123adduser gitchmod 740 /etc/sudoers //写权限vim /etc/sudoers 打开sudoers修改git用户的权限(在原始文件中添加一行) sudoers12root ALL=(ALL) ALL+ git ALL=(ALL) ALL 给git用户添加密码 1sudo passwd git 生成一对ssh认证密钥(防止一直输入密码) 12345su gitcd /home/gitmkdir /blog/.sshcd blog/.sshssh-keygen -t rsa 以下在本地端操作 1ssh-keygen -t rsa 将本地生成的ssh-keygen上传到远程服务器，这样就不要每次都要输出密码 1ssh-copy-id -i C:/Users/Administrator/.ssh/id_rsa.pub git@111.229.248.67 测试ssh远程登录是否成功，必须免密才算成功 1ssh git@111.229.248.67 自建Git Bare仓库并利用钩子(hooks)拷贝到网站根目录 自建Git裸仓库(Bare) 123mkdir -p /home/git/blog/hexo.git #准备成为Git仓库mkdir /home/git/blog/hexo #存储网站文件（文章啦渲染之类的）git init --bare /home/git/blog/hexo.git #设为git仓库，--bare代表这是裸库，裸库没有工作区，我们不会在裸库上进行操作，它只为共享而存在 裸仓库与 git init 初使化的仓库不太一样，裸仓库其实相当于通过克隆来的仓库里的.git文件夹，整个裸仓库中只有git索引（index），不包含工作目录。 创建钩子Hooks将目录切换至 /home/git/blog/hexo.git/hooks，用 cp post-update.sample post-update 复制并重命名文件后,vim post-update 修改，增加执行脚本: 123cd /home/git/blog/hexo.git/hooks //进入该仓库cp post-update.sample post-updatevim post-update post-update文件中原来有一行脚本，此时需要删除(这个坑卡了好久) post-update123456789#!/bin/sh-- exec git update-server-info++ DIR=/home/git/blog/hexo++ git --work-tree=${DIR} clean -fd++ git --work-tree=${DIR} checkout --force Git 钩子存在于每个 Git 仓库的 .git/hooks 目录中。 当你用 git init 初始化一个新版本库时，Git 默认会在这个目录中放置一些示例脚本。所有的示例都是 shell 脚本，其中一些还混杂了 Perl 代码，不过，任何正确命名的可执行脚本都可以正常使用 —— 你可以用 Ruby 或 Python，或其它语言编写它们。.sample拓展名是为了防止它们默认被执行，安装一个钩子只需要去掉.sample拓展名即可。 赋予可执行权限 1chmod +x post-update 安装nginx并配置服务器信息 12yum install nginxvim /etc/nginx/nginx.conf 配置文件nginx.conf中，第一行的user 要改成root,server_name改成服务器ip地址或者域名,root改成hexo网站文件存储路径 在/home/git/blog/hexo新建index.html(网站首页),加入如下代码： index.html12345678910&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;title&gt;&lt;/title&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;/head&gt; &lt;body&gt; &lt;p&gt;Nginx running&lt;/p&gt; &lt;/body&gt;&lt;/html&gt; 访问服务器 IP 或者域名显示Nginx running,则说明nginx配置成功 本地配置_config.yml 打开站点配置文件_config.yml,配置deployer仓库信息_config.yml123repo: vps: git@111.229.248.67:/home/git/blog/hexo.git github: https://github.com/MasterXuBoya/masterxuboya.github.io.git git表示远程主机的用户名，111.229.248.67是服务器ip，/home/git/blog/hexo.git 是远程主机的仓库。注意：此处不要写成/home/git/blog/hexo，该目录是网站根目录，是.git仓库中的内容经过hooks自动生成的 发布1hexo clean &amp;&amp; hexo g &amp;&amp; hexo s 此时代码自动部署到GitHub和vps服务器的/home/git/blog/hexo.git目录 如果此时通过putty工具访问vps，cd到/home/git/blog/hexo.git目录，发现并没有上传的文件，其实只是git类型的文件不显示而已。如果在本地执行git clone /home/git/blog/hexo.git，是可以看到生成的文件的。打开/home/git/blog/hexo，发现静态网页已经同步到该目录，启动nginx即可通过ip远程访问，至此完成网站的远程自动部署。 服务器端常见命令网站根目录：/home/git/blog/hexogit仓库：/home/git/blog/hexo.git 查看端口进程：netstat -ntlp查看nginx进程：ps -ef|grep nginx 测试nginx.conf文件配置是否正确:nginx -t 查找到nginx对应的pid之后，可以重启nginx服务器，有以下两种方式：重启nginx：kill -HUP pid重启nginx:nginx -s reload 参考网址https://blog.csdn.net/jiachunchun/article/details/90235492https://blog.csdn.net/weixin_34413802/article/details/88986540用 Git 钩子进行简单自动部署git钩子 hook post-receive","link":"/2020/02/29/Hexo%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E7%9A%84%E5%AE%89%E8%A3%85%E4%B8%8E%E9%83%A8%E7%BD%B2/"},{"title":"数据库基础知识","text":"引言数据库基本概念数据库系统包括以下内容 数据库—表：相互有关联的数据的集合 数据库管理系统DBMS（MySQL、DB2、Oracle等） 从用户角度（用户使用角度）： 数据定义语言DDL 数据操纵语言DML 数据控制语言DCL 嵌入式数据库语言(Java调用SQL) 从系统角度（系统实现角度） 语言编译器 查询优化与实现 存储与索引 通信控制：分布式数据库 事务机制 故障恢复 安全性控制 完整性控制 数据库性能分析 各种控制程序 数据库应用程序：图书订阅系统、学生成绩管理系统等业务系统 数据库管理员DBA 课程内容概览该MOOC课程主要分成以下四个部分： 关系模型理论：基本的关系模型理论 数据库语言SQL：介绍SQL的DDL和DML语言 数据建模与数据库设计：介绍范式理论，数据建模方法，如何建表 数据库管理系统的实现技术：介绍如何实现数据库管理系统 关系模型理论基本概念三级模式两层映像 三级模式 External Level = User Level 某一用户能够看到和处理的数据，全局数据中的某一部分 Conceptual Level=Logic Level 从全局角度理解/管理的数据，含有相应的约束 Internal Level=Physical Level 存储在介质上的数据，含存储路径、存储方式、索引方式等 两层映像 E-C Mapping 将外模式映射为概念模式，从而支持实现数据概念视图想外部视图的转换，便于用户观察和使用 C-I Mapping 将概念模式映射为内模式，从而实现数据概念视图想内部视图的转换，便于计算机进行存储和处理 两个独立性 概念数据独立性 当概念模式发生改变时，可以不改变外模式，只要改变(E-C Mapping)，从而无需改变应用程序 物理数据独立性 当内部模式发生变化时，可以不改变概念模式，只需改变C-I Mapping，从而不改变外部模式 三大经典数据模式 关系模型(第二代数据库基本理论) 层次模型（树结构） 网状模型（图结构） 关系模型的三要素 表的基本结构 域:某一列的值域 候选码：可以唯一表征一行的某个属性或组合属性 主键：从候选码中选取一个作为主键，通常选单一列 外码：A的某一个列（非主键）是B表的主键（Key） 关系运算 内容跳转 完整性约束 实体完整性：主键非空 参照完整性：外键必须在B表中存在 用户自定义完整性：常用于数据监控和清洗，如性别字段只能为男女，年龄字段必须为200内的整数等用户自定义的条件 关系代数 并 前提：两个表的字段类型一致 交 差 以上三个概念同集合论中定义 选择：选取行 where 投影：选取列 select 积：笛卡尔积 无连接条件 连接 θ连接：有连接条件，等同于笛卡尔积后，选取R中属性A与S中属性B之间满足θ条件的元组 等值连接：特殊的θ链接，θ条件是＝ 自然连接：特殊的等值连接，连接条件是表R和表S中具有相同名称的字段 外连接 左外连接 R left out join S on R.A=S.B R首先与S进行笛卡尔积等得到D，然后对于R中的每一行，通过R.A=S.B在D中筛选。对于某一行，可能在S中存在多行满足R.A=S.B，全部保留； R.A=S.B的条件在S中可能一行也不存在，这时R中的每一行都必须有一个结果，S为空 右外连接 right out join 全外连接 full out join 除法 前提：R÷S的前提是，S的属性必须是R的真子集 具体演示： 关系演算关系代数通过集合的形式进行关系运算，而关系演算则通过数理逻辑的方式进行关系运算，此处不详细研究 数据库语言SQLSQL语言集DDL、DML、DCL于一体。大的来说，主要有以下9个关键词，每种都可以表达复杂的操作请求 DDL语言引导词：Create、Alter、Drop 模式的定义和删除、包括定义DataBase、Table、View、Index、完整性约束条件等，也包括定义对象（RowType行对象、Type列对象） DML语句引导词（增删查改）、Insert、Delete、Update、Select DCL语句引导词：Grant、Revoke 安全性控制：授权和取消授权 DDL Create 12345678Create database 数据库名Create table 表名(列名 数据类型 [Primary key|Unique] [Not null] 列名 数据类型 )Unique:是否候选码Create view viewName as select 子查询CREATE ASSERTION &lt;assertion-name&gt; CHECK &lt;predicate&gt; Alter 1234alter table tablename[add {colname datatype, …}] 增加新列[drop { 完整性约束名}] 删除完整性约束[modify {colname datatype, …}] 修改列定义 Drop 123drop database 数据库名drop table 表名drop view viewName Drop对应于Create，有Create就有相应的Drop Drop删除的是表的结构，不同于delete 切换/关闭数据库 12use databaseclose database 完整性约束 这是所说的完整性约束包括实体完整性、参照完整性、用户自定义完整性的SQL实现 基本概念 Integrity Constraint=（O，P，A，R） ​ O：数据集合：约束的对象？​ 列、多列(元组)、元组集合​ P：谓词条件：什么样的约束？​ A：触发条件：什么时候检查？​ R：响应动作：不满足时怎么办？ 基本分类 静态约束 列完整性—域完整性约束 表完整性–关系完整性约束 动态约束 触发器 静态约束 对象O是列或者表，谓词条件P是约束条件，触发条件A是数据库更新时，响应动作R为空 123456789Create Table Course ( C# char(3) , Cname char(12), Chours integer, Credit float(1) constraint ctcredit check (Credit &gt;=0.0 and Credit&lt;=5.0 ), T# char(3) references Teacher(T#) on delete cascade //以上是列完整性约束 , primary key(C#) ,constraint ctcc check(Chours/Credit = 20) ); //以上是表完整性约束 列完整性约束通过空格分隔，表完整性约束通过,分隔 列完整性约束 1234567{ NOT NULL | //列值非空 [ CONSTRAINT constraintname ] //为约束命名，便于以后撤消 { UNIQUE //列值是唯一 | PRIMARY KEY //列为主键 | CHECK (search_cond) //列值满足条件,条件只能使用列当前值 | REFERENCES tablename [(colname) ] [ON DELETE { CASCADE | SET NULL } ] } } 表完整性约束 123456789[ CONSTRAINT constraintname ] //为约束命名，便于以后撤消 { UNIQUE (colname {, colname. . .}) //几列值组合在一起是唯一 | PRIMARY KEY (colname {, colname. . .}) //几列联合为主键 | CHECK (search_condition) //元组多列值共同满足条件 //条件中只能使用同一元组的不同列当前值 | FOREIGN KEY (colname {, colname. . .}) REFERENCES tablename [(colname {, colname. . .})] [ON DELETE CASCADE] } //引用另一表tablename的若干列的值作为外键 check 中的条件可以是Select-From-Where 内任何Where后的语句，包含子查询 Alter修改完整性约束 1234567891011ALTER TABLE tblname [ADD ( { colname datatype [DEFAULT {default_const|NULL} ] [col_constr {col_constr...} ] | , table_constr } {, colname ...}) ] [DROP { COLUMN columnname | (columnname {, columnname…})}] [MODIFY ( columnname data-type [DEFAULT {default_const | NULL } ] [ [ NOT ] NULL ] {, columnname . . .})] [ADD CONSTRAINT constr_name] [DROP CONSTRAINT constr_name] [DROP PRIMARY KEY ] ; 断言 1CREATE ASSERTION &lt;assertion-name&gt; CHECK &lt;predicate&gt; 由于每次更新数据库都要检测所有断言，判断是否满足条件；因此，类似C 的goto，慎用断言！ 动态约束（触发器Trigger） 不同于静态约束，O、P、A、R均需要定义 12345678CREATE TRIGGER trigger_name BEFORE | AFTER { INSERT | DELETE | UPDATE [OF colname {, colname...}] } ON tablename [REFERENCING corr_name_def {, corr_name_def...} ] [FOR EACH ROW | FOR EACH STATEMENT] //对更新操作的每一条结果(前者)，或整个更新操作完成(后者) [WHEN (search_condition)] //检查条件，如满足执行下述程序 { statement //单行程序直接书写，多行程序要用下行方式 | BEGIN ATOMIC statement; { statement;...} END } 触发对象：[OF colname {, colname...}] } ON tablename 触发时机：BEFORE | AFTER { INSERT | DELETE | UPDATE 约束条件：[WHEN (search_condition)] 响应动作：{ statement //单行程序直接书写，多行程序要用下行方式 | BEGIN ATOMIC statement; { statement;...} END } 对象别名：[REFERENCING corr_name_def {, corr_name_def...} ] 123456corr_name_def 的定义{ OLD [ROW] [AS] old_row_corr_name //更新前的旧元组命别名为| NEW [ROW] [AS] new_row_corr_name //更新后的新元组命别名为| OLD TABLE [AS] old_table_corr_name //更新前的旧Table命别名为| NEW TABLE [AS] new_table_corr_name //更新后的新Table命别名为} 典型应用场景： 设计一个触发器当进行Teacher表更新元组时, 使其工资只能升不能降 12345678create trigger teacher_chgsal before update of salary on teacher referencing new x, old y for each row when (x.salary &lt; y.salary) begin raise_application_error(-20003, 'invalid salary on update'); //此条语句为Oracle的错误处理函数 end; 触发对象：teacher表的salary字段 触发时机：before update 约束条件：(x.salary &lt; y.salary)即更新的salary值小于原始的值 响应动作：提示错误 假设student(S#, Sname, SumCourse), 当删除某一同学S#时，该同学的所有选课也都要删除。 123456create trigger delS# after delete on Student referencing old oldi for each row begin delete sc where S# = :oldi.S# ; end; 触发对象：Student表 触发时机：after delete 约束条件：无 响应动作：删除student某一行后，与之相关的sc表的相应多行数据也要删除。 背景：某个学生退学后，他的所有课程成绩也要删除 假设Dept(D#, Dname, Dean), 而Dean一定是该系教师Teacher(T#,Tname, D#, Salary)中工资最高的教师。 123456789create trigger upddean before update of Dean on Dept referencing old oldi, new newi for each row when ( dean not in (select Tname from Teacher where D# = :newi.D# and salary &gt;= all (select salary from Teacher where D# = :newi.D#)) begin raise_application_error(-20003, 'invalid Dean on update'); end; 触发对象：Dept表的Dean字段 触发时机：before update 约束条件：Dept表某一行的D#不是该系教师的最高工资 响应动作：提示警告 :star2: 触发器是一种动态完整性约束，另外一种等效的实现方式是数据库应用程序使用SQL多条语句实现，需要程序员自己操纵，更新多个表。如案例2中，删除Student表的某条记录后，可以通过多条SQL语句更新SC表等其他表，也可以实现和触发器同样的功能。 DML Insert 插入单条记录 12insert into 表名 [ ( 列名 [, 列名 ]… ] values (值 [, 值] , …) ; values 后面值的排列，须与into 子句后面的列名排列一致若表名后的所有列名省略， 则values后的值的排列，须与该表存储中的列名排列一致 插入多条记录 12insert into 名 表名 [( 列名[ ，列名]…)]select子查询 Delete Update Select 123456789//简例select distinc a.*,b.col1,b.col2 from a left out join bon a.col=b.co1where group byhaving order byasc/desc 123456789SELECT [ALL|DISTINCT|DISTINCTROW|TOP]{*|talbe.*|[table.]field1[AS alias1][,[table.]field2[AS alias2][,…]]}[case when]FROM tableName[WHERE…][GROUP BY…][HAVING…][ORDER BY…][LIMIT] :star2: 顺序：先where筛选（行），然后根据groupby分组，（此处进行select筛选列），再通过having筛选分组（组），order by排序，limit限制输出行数 模糊查询 1234567891011//检索所有姓张的学生学号及姓名Select S#, Sname From StudentWhere Sname Like ‘ 张%’ ;//检索名字为张某某的所有同学姓名Select Sname From StudentWhere Sname Like ‘ 张_ _’;//检索名字不姓张的所有同学姓名Select Sname From StudentWhere Sname Not Like ‘ 张%’; 多表联合查询 12select a.col1,b.*from a,b//此处逗号分隔相当于笛卡尔积 子查询 in/not in θsome/θall 常用于查询最大最小值 123典型案例：查询最低工资的教师姓名Select Tname From TeacherWhere Salary &lt;= all ( Select Salary From Teacher ); exist/not exist 并- 交- 差 并 Union/Union ALL 交 Intersect/Intersect ALL 差 Except/Except ALL 上述三个命令，不带ALL自动删除重复元组。如果需要保留重复元组需要使用ALL，假设子查询1的一个元组出现m次，子查询2的一个元组出现n次，则该元组在： 子查询1 Union ALL 子查询2 ，出现m + n次 子查询1 Intersect ALL 子查询2 ，出现min(m,n)次 子查询1 Except ALL 子查询2 ，出现max(0, m – n)次 DCL—数据库安全自主安全性机制：存取控制(AccessControl) 通过权限在用户之间的传递，使用户自主管理数据库安全性强制安全性机制：通过对数据和用户强制分类，使得不同类别用户能够访问不同类别的数据 自主安全性机制 自主安全性是通过授权机制来实现的 户在使用数据库前必须由DBA 处获得一个账户，并由DBA授予该账户一定的权限，该账户的用户依据其所拥有的权限对数据库进行操作授予该账户一定的权限，该账户的用户依据其所拥有的权限对数据库进行操作; 同时，该帐户用户也可将其所拥有的权利转授给其他的用户同时，该帐户用户也可将其所拥有的权利转授给其他的用户( 账户)，由此实现权限在用户之间的传播和控制。 基本思路 AccessRule ::= ( S, O, t, P) S: 请求主体( 用户)——用户多时，可以按用户组建立访问规则 O: 访问对象——访问对象可大可小(目标粒度Object granularity):属性/字段、记录/元组、关系、数据库 t: 访问权利——包括创建、增、删、改、查等 P: 谓词——拥有权利需满足的条件 自主安全性的实现方式 存储矩阵 视图 根据需求定义不同用户级别可以看到的视图，再利用Grant命令将视图赋值给用户 Grant 1234GRANT {all PRIVILEGES | privilege {,privilege…}}ON [TABLE] tablename | viewnameTO {public | user-id {, user-id…}}[WITH GRANT OPTION]; Grant命令粒度比较大，用于表名和视图 Revoke——撤销授权 12REVOKE {all privilEges | priv {, priv…} } ON tablename | viewnameFROM {public | user {, user…} }; A–&gt;B–&gt;C，当B撤销授权时，C也同时撤销 强制安全性机制 暂未学习 视图12create view view_name [( 列名[ ，列名] …)]as 询 子查询 [with check option] ​ 不像base table，视图是一个想象的表，实际物理存储中并不存在。当需要使用某个视图时，才执行视图生成命令。视图生成之后，可以和普通表一样的访问方式。一般视图仅用于select，是使用更新命令（增删改）。 SQL ServerSQL Server 的系统数据库 Master ： 是SQL Server中最重要的系统数据库，存储中最重要的系统数据库，存储SQL Server 中的元数据。 Model： 模板数据库，在创建新的数据库时，SQL Server将会复制此数据库作为新数据库的基础 Msdb： 代理服务数据库，提供一个存储空间。 Tempdb： 临时数据库，为所有的临时表、临时存储过程及其他临时操作提供存储空间，断开连接时，临时表与存储过程自动被删除。 Master数据库是存储表结构的数据库 数据字典数据字典就是数据库的元数据，存储表的结构信息，是数据的数据 列的元数据信息如下图所示,通过下述sql语句可以查询STUDENT表的所有列信息 非常类似高级语言中的反射功能，提供一组API对数据结构信息进行访问 12Select Column_Name From ALL_TAB_ColumnsWhere Table_Name = ‘STUDENT’ ; 嵌入式SQL&amp;ODBC&amp;JDBC 几个基本问题 在高级语言中嵌入SQL，存在以下几个基本问题 ODBC/JDBC ODBC供C,C++, C#, Visual Basic, Power Builder调用数据库 JDBC供Java调用数据库 ODBC/JDBC隔离应用程序和DBMS之间的交互，在中间插入ODBC/JDBC层，可以实现对多种数据库，如Mysql、Oracle、DB2等多种数据库管理系统的交互。程序员主要调用ODBC/JDBC提供的API函数，不用直接与DBMS对接。 框架的作用 程序员在实际开发中一般也不用直接操纵ODBC/JDBC，一般高级语言框架实现对数据库的简单高效访问。例如Java 的Spring框架在ODBC/JDBC的基础上进一步封装函数，Go语言的Gin框架等。程序员在真正实现的时候其实是比较简单的，框架已经把大部分的工作做好了。 使用框架开发应用程序，需要注意以下几个问题： 宿主语言和SQL同一列数据类型的差异 where中多个条件的And连接符问题，自己拼接字符串有这个问题，框架应该都做好了 宿主语言向SQL数据注入的方式 123select XXXfrom XXXwhere name=XXX and id=XXX XXX都是可以用Java变量注入的，需要注意传入的书写方式 高级语言如何处理数据库事务机制——commit与rollback 自己拼接字符串引发的SQL注入漏洞 数据建模与数据库设计数据库管理系统的实现技术 Database System Implementation ,2ndEdition,机械工业出版社，2010 物理存储存储单位：bit、Byte、KB、MB、GB、TB、PB、EB、ZB、YB、BB 内存页（Page）=磁盘块（Block） 页面置换算法 RAID技术 并行处理 :并行读取多个磁盘 比特级拆分:一个字节被拆分成8个比特位,不同比特位存储于不同磁盘.、 块级拆分: 一个文件由多个块组成，不同块存储于不同磁盘. 可靠性 :奇偶校验与纠错 扇区/块读写校验：对一个扇区/块读写做校验 磁盘间读写校验: 多个磁盘间共同构成的信息读写做校验 索引技术索引文件是一种辅助存储结构，其存在与否不改变存储表的物理存储结构；然而其存在，可以明显提高存储表的访问速度。 有索引时，更新操作必须同步更新索引文件和主文件 索引文件比主文件小很多。通过检索一个小的索引文件(可全部装载进内存)，快速定位后，再有针对性的读取非常大的主文件中的有关记录 SQL 12345CREATE [unique] INDEX indexname ON tablename ( colname [asc | desc] {, colname [asc | desc] . . .} ); DROP INDEX indexname; 索引分类 稠密索引 与 稀疏索引 主索引与辅助索引 聚簇索引 倒排索引 B+树基础知识B+树的基本性质（m阶的B树） 叶子节点才是真正存储数据的地方，非叶结点仅具有索引作用，跟记录有关的信息均存放在叶结点中。 叶子节点有序链表：树的所有叶结点构成一个有序链表，可以按照关键码排序的次序遍历全部记录 根结点至少有两个子女 每个中间节点都至少包含ceil(m / 2)个孩子，最多有m个孩子。中间节点不包含真实的数据指针 每一个叶子节点都包含k-1个元素，其中 m/2 &lt;= k &lt;= m。 所有的叶子结点都位于同一层 1234567891011struct RealNode;//数据库中的一条记录Recordstruct DataNode{ int key;//索引Key RealNode *value;//指向真实数据的指针};//真实数据struct TreeNode{ vector&lt;DataNode&gt; value;//当前节点的所有数据 vector&lt;TreeNode *&gt; son;//儿子数组 TreeNode *next;//叶子 ` 节点特有的链表结构} B+树基本操作 建树（插入） 查找 删除 B+树的优点 比起B树，B+树 ①IO次数更少 ②查询性能很稳定 ③范围查询更简便 B+树中间节点没有Data数据，所以同样大小的磁盘页可以容纳更多的节点元素。所以数据量相同的情况下，B+树比B树更加“矮胖“，因此使用的IO查询次数更少。 B即Balance的缩写，是一棵平衡多叉树 区间查询类似线段树的操作，更加方便.所有叶子节点形成有序链表，便于范围查询 B+树在数据库中应用基本特征 非叶结点指针指向索引块，叶结点指针指向主文件的数据块或数据记录 指向主文件的指针仅出现于叶结点（真实存储数据） 所有叶结点即可覆盖所有键值的索引 索引字段值在叶结点中是按顺序排列的 具体实施方式（数据库的什么部分是B+树的Key） 用B+树建立键属性稠密索引 ​ 索引字段是主文件的主键，索引是稠密的。指针指向的是记录。表的存储方式(主文件)可以按主键排序，也可以不按主键排序 用B+树建立稀疏索引(或主索引) ​ 索引字段是主文件的主键，索引是稀疏的。主文件必须按主键排序。指针指向的是数据块,一个数据块中可能存在多条数据 用B+树建立非键属性稠密索引 ​ 采用表的非主键字段作为B+树的Key，由于非主键字段可能存在重复，但是索引文件的索引字段是无重复的。主文件按非键属性排序。指针指向的是记录。 该方法类似前向星存图的过程，主文件按照某个字段排序，然后记录每个字段的起始位置 用B+树建立非键属性稠密索引 索引字段是主文件的非键属性。主文件不按此非键属性排序。索引文件的索引字段值是有重复的。指针指向的是记录。 B+树 vs B树 B树 索引字段值仅出现一次或者在叶结点或者在非叶结点； 指向主文件的指针出现于叶结点或非叶结点； 所有结点才能覆盖所有键值的索引 散列索引 静态散列索引：桶的数目M是固定值 动态散列索引：桶的数目随键值增多，动态增加 可扩展散列索引 线性散列索引 可扩展散列索引——桶的数量每次翻倍 参数k——i可能的最大的值， 可能的最大桶的数目为 2^k ，逐渐被使用 参数i——i 为散列函数当前已经使用到的最多位数 参数n=2^i ——当前桶数 实现方案 散列函数h(k)是k的二进制的前i位，放入到对应桶中 如果当前桶放不下，此处存在两种情况； 如当前桶已经是最细粒度的桶，那么对全局的i++，增加桶的数量。把当前桶分裂成两个桶，对应的数据分到两个桶中；其他的桶也分裂成两个桶，但是指向同一个数据块 如果当前桶不是最细粒度的桶，那么将当前的桶进行分裂即可，空间×2，其他桶不需要进行操作。 并非每个桶都有一个数据块；如果某些桶中的所有记录可以放在一个块中，则这些桶可能共享一个块。 缺点 当桶数组需要翻倍时，要做大量的工作(当i很大时)； 当桶数翻倍后，其在主存中可能就装不下了，或者要占用更大的空间 如果每块的记录数很少，那么很有可能某一块的分裂比在逻辑上需要的分裂时间提前很多 线性散列索引——桶的数量每次+1 实现方案 散列函数h(k)是k的二进制的后i位，放入到对应桶中（如果h(k)桶不存在另外处理） 桶数n的选择总是使存储块的平均记录数保持与存储块所能容纳的记录总数成一个固定的比例，例如80%。超过此比例，则桶数增长1块，分裂 分裂规则：0–&gt;00,10 1–&gt;01,11 00–&gt;000,1000 查询实现算法 ​ 将SQL语句首先编译成基础的关系运算，如交并补、选择、投影等，这个过程可以调整顺序从而实现SQL查询优化。然后进入物理查询优化：同一个“连接”操作可能由于存储方法、索引方法等的不同，在底层通过不同的物理存储实现（同一关系操作的不同物理例行程序）。物理优化主要解决内存和磁盘的交互问题，尽量减小磁盘I/O的次数，提高内存查询的效率。 数据库的三大类操作 一次单一元组的一元操作：选择、投影 通过迭代器算法实现 整个关系（表）的一元操作：DISTINCT、Group by、sorting 整个关系的二元操作：交并补、积、连接等 以上两者通过一趟扫描算法、两趟扫描算法、多趟扫描算法实现。底层具体通过排序技术、散列技术、索引技术实现 连接操作的逻辑实现和物理实现 逻辑实现比较简单，扫描R表的每一个记录，S表的每一个记录，如果R.A==S.A，那么表示两个记录可以连接 物理实现比较复杂，表的记录存储在硬盘上，以磁盘块为存储单位，每一个Block上存储多条记录。 Algorithm 1 黑色的表示磁盘I/O操作，蓝色的表示内存操作，时间复杂度主要集中在磁盘操作 ​ 每次读取R表中的一个Block和S表的一个Block，然后扫描连接。 ​ 时间复杂度：BR+BRBS ​ 空间复杂度：占用内存3b (b是一个磁盘块大小) Algorithm 2——全主存 前提：两个表都可以载入内存，把两个表的所有Block都载入内存 ​ 时间复杂度：BR+BS Algorithm 3——半主存 前提：一个表可以放入内存，另外一个大表不行，类似大数据的Mapjoin ​ 时间复杂度：BR+BS Algorithm 4 两个表均无法放入内存，将R表每次选M-2个Block放入内存，S表每次选1个Block载入内存，还有一个Block用于存放最终结果。 ​ 时间复杂度：BRBs/(M-2)+BS Algorithm 5、 对Algorithm4内存部分可以进行改进，通过建立Hash表对M-2个Block进行快速检索，而不是上述方法的简单扫描。 迭代器方法——单一元组一元操作 不同于物化计算策略，迭代器方法用于流水线计算策略，该方法不需要保存中间结果，连接操作的中间结果很可能引起维度爆炸 通过迭代器方法扫描表，本质上就是对磁盘Block进行封装，依次读取每个Block的每一条记录 一趟扫描算法​ 本质就是通过排序、散列、B+树等建立一个可以快速检索的数据结构，然后从表格中每次读取一条记录就进行检索。前提是内存可以容得下该数据结构 基于索引的算法——索引技术是如何加速查找的 基于索引的选择 基于索引的连接——Zig-Zag连接算法 双指针 两趟扫描算法 本质就是多路归并排序 基本原理 问题：内存只有4GB，待排序文件100GB，如何排序？（外排序问题） ​ 将100GB分成多个子集，每个子集2GB，刚好可以装入内存（此处最好让内存有其他空间）。将每个子集分别装入内存进行排序后输出到磁盘，此时磁盘中有50个已经排好序的大小为2GB的文件。 ​ 从每个子集文件（2GB）中读取一小段数据（size*50≈2GB）载入内存，使得总的大小小于内存大小。其实每次可以从每个子集中读取一个数据，但是这样会涉及到较多的I/O操作，降低效率；因此，每次应该尽量多的读取数据到内存。接下来的过程就是一个改进版的多路归并排序过程：50个排好序的序列进行多路归并，使用小根堆优化；当某一路数据结束的时候需要继续从磁盘中读取后边的数据。 Distinct 第一趟：划分子表，并进行子表排序第二趟：归并阶段，在排序的基础上，直接将重复的记录剔出掉-不输出 归并过程中，弹出最小值和上一次弹出来的最小值一样就删除 Groupby 第一趟：划分子表，并进行子表排序第二趟：归并阶段，在排序基础上，将不重复的记录，作为新分组输出；重复的记录进行分组聚集计算。 按照Groupby的键进行排序，归并过程同样的记录分组聚集 交并补 Union All直接将两个表叠加 Union类似Distinc过程，需要去重复 join R和S分别按照连接键排序，这个地方我觉得可以用两个小根堆维护，相当于R和S分别整体有序的序列，然后使用双指针（Zig-Zag连接算法） 查询优化 逻辑查询优化​ SQL表达式通过编译，形成基本的关系代数表达式，但是此表达式一般不能直接执行，通常该表达式不是最优执行顺序，因此需要对关系表达式进行优化。逻辑查询优化主要的工作就是优化语法树，改变操作顺序。优化策略包括：尽可能地早做选择和投影、把选择与投影串接起来…… ​ 通过一些基本定理——关系代数操作次序交换的等价性，可以将SQL语句优化成最优的关系表达式 物理查询优化​ 对于逻辑查询优化后得到的关系代数表达式，每一个基本操作，如“选择”，“投影”，“连接”等都有多种物理实现，大的方面包括迭代器方法、一趟扫描方法、两趟扫描方法，具体底层实现又可以分成排序方法、散列方法、索引方法。因此对于一个固定的关系代数表达式，通常存在多种物理实现的策略。对于每一种策略，需要评估该实现方法的代价。评估的方法就是利用数据字典，利用关系的元数据信息，如“表的记录数”、“Block数”、“不同属性的个数”等信息，评估每种方案的代价，最后选择一种最优的物理实现策略。确定方案之后，交给下层的计算引擎实现。 事务处理技术 InnoDB，是MySQL的数据库引擎之一，现为MySQL的默认存储引擎 ​ 通常事务必须满足4个条件（ACID）：原子性（Atomicity，或称不可分割性）、一致性（Consistency）、隔离性（Isolation，又称独立性）、持久性（Durability）。 1、A (Atomicity) 原子性 原子性很容易理解，也就是说事务里的所有操作要么全部做完，要么都不做，事务成功的条件是事务里的所有操作都成功，只要有一个操作失败，整个事务就失败，需要回滚。 比如银行转账，从A账户转100元至B账户，分为两个步骤：1）从A账户取100元；2）存入100元至B账户。这两步要么一起完成，要么一起不完成，如果只完成第一步，第二步失败，钱会莫名其妙少了100元。 2、C (Consistency) 一致性 一致性也比较容易理解，也就是说数据库要一直处于一致的状态，事务的运行不会改变数据库原本的一致性约束。 例如现有完整性约束a+b=10，如果一个事务改变了a，那么必须得改变b，使得事务结束后依然满足a+b=10，否则事务失败。 3、I (Isolation) 独立性 所谓的独立性是指并发的事务之间不会互相影响，如果一个事务要访问的数据正在被另外一个事务修改，只要另外一个事务未提交，它所访问的数据就不受未提交事务的影响。 比如现在有个交易是从A账户转100元至B账户，在这个交易还未完成的情况下，如果此时B查询自己的账户，是看不到新增加的100元的。 4、D (Durability) 持久性 持久性是指一旦事务提交后，它所做的修改将会永久的保存在数据库上，即使出现宕机也不会丢失。 面试题事务的基本要素 事务隔离级别 如何解决事务的并发问题(脏读，幻读)？ MVCC多版本并发控制？ binlog,redolog,undolog都是什么，起什么作用？ InnoDB的行锁/表锁？ myisam和innodb的区别，什么时候选择myisam？ 为什么选择B+树作为索引结构？ 索引B+树的叶子节点都可以存哪些东西？ 查询在什么时候不走（预期中的）索引？ sql如何优化? explain是如何解析sql的？ order by原理 Reference哈尔滨工业大学数据库课程Mooc","link":"/2020/04/03/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"},{"title":"MarkDown基本语法","text":"标题&amp;字体标题# 一级标题 ## 二级标题 ### 三级标题 #### 四级标题一、标题 html标签 字体🌟 New Features红色斜体字粗体字斜体加粗删除线 列表 无序列表(+-*) 有序列表(1.) 列表嵌套 列表嵌套 列表嵌套 代码123$ ls$ mkdir blog$ hexo server 1234567#include &lt;iostream&gt;#include &lt;stdio.h&gt;using namespace std;int main(){ cout&lt;&lt;\"hello Hexo\"&lt;&lt;endl; return 0;} 12345import numpy as npimport pandas as pddef func(argc,arg): a=input() return a 超链接 两种基本形式 http://www.baidu.com 百度 图片![风景图片](hexo MarkDown基本语法/example.jpg “示例图片”) 表格 表头1 表头2 表头3 内容11 内容12 13 内容21 内容22 23 表头1 表头2 表头3 表头4 默认左对齐 左对齐 居中对其 右对齐 默认左对齐 左对齐 居中对其 右对齐 默认左对齐 左对齐 居中对其 右对齐 公式$y=x+1$ $ \\Gamma(z) = \\int_0^\\infty t^{z-1}e^{-t}dt. $ $$\\Gamma(z) = \\int_0^\\infty t^{z-1}e^{-t}dt.$$ 文件下载","link":"/2020/02/21/MarkDown%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/"},{"title":"Kickstart Round A 2020","text":"Problem 1 AllocationProblemThere are N houses for sale. The i-th house costs Ai dollars to buy. You have a budget of B dollars to spend. What is the maximum number of houses you can buy? InputThe first line of the input gives the number of test cases, T. T test cases follow. Each test case begins with a single line containing the two integers N and B. The second line contains N integers. The i-th integer is Ai, the cost of the i-th house. OutputFor each test case, output one line containing Case #x: y, where x is the test case number (starting from 1) and y is the maximum number of houses you can buy. LimitsTime limit: 15 seconds per test set.Memory limit: 1GB.1 ≤ T ≤ 100.1 ≤ B ≤ 105.1 ≤ Ai ≤ 1000, for all i. Test set 11 ≤ N ≤ 100. Test set 21 ≤ N ≤ 105. 分析贪心算法，挑选最小的买 代码1234567891011121314151617181920212223242526272829#include&lt;stdio.h&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;string.h&gt;#define maxn 100010using namespace std;int T,n,b;int a[maxn];int main(){ int i,j,t,ans; cin&gt;&gt;T; for(t=1;t&lt;=T;t++){ cin&gt;&gt;n&gt;&gt;b; for(i=0;i&lt;n;i++) cin&gt;&gt;a[i]; sort(a,a+n); ans=0;i=0; while(i&lt;n&amp;&amp;b&gt;=a[i]){ ans++; b-=a[i]; i++; } printf(\"Case #%d: %d\\n\",t,ans); }} Problem 2 PlatesProblemDr. Patel has N stacks of plates. Each stack contains K plates. Each plate has a positive beauty value, describing how beautiful it looks. Dr. Patel would like to take exactly P plates to use for dinner tonight. If he would like to take a plate in a stack, he must also take all of the plates above it in that stack as well. Help Dr. Patel pick the P plates that would maximize the total sum of beauty values. InputThe first line of the input gives the number of test cases, T. T test cases follow. Each test case begins with a line containing the three integers N, K and P. Then, N lines follow. The i-th line contains K integers, describing the beauty values of each stack of plates from top to bottom. OutputFor each test case, output one line containing Case #x: y, where x is the test case number (starting from 1) and y is the maximum total sum of beauty values that Dr. Patel could pick. LimitsTime limit: 20 seconds per test set.Memory limit: 1GB.1 ≤ T ≤ 100.1 ≤ K ≤ 30.1 ≤ P ≤ N * K.The beauty values are between 1 and 100, inclusive. Test set 11 ≤ N ≤ 3. Test set 21 ≤ N ≤ 50. 分析典型的背包问题，假设原始数据为a[N][K]数组，第i堆前j个和为s[i]j.从最后一堆分析起，最后一堆可以选0个、1个、2个……K个，然后前N-1个依然是最优子问题。 伪递推方程为：f(N,P)=f(N-1,i)+s[N][i] 0≤i≤min(K,P)。 边界条件：f(0,0)=0,f(0,i)=-MAXN i&gt;0,f(i,0)=0 i&gt;0. 代码123456789101112131415161718192021222324252627282930313233343536#include&lt;iostream&gt;#include&lt;stdio.h&gt;#include&lt;string.h&gt;#include&lt;stdlib.h&gt;#include&lt;cstring&gt;#define maxn 100000000using namespace std;int a[60][32],s[60][32];int w[60][1600];int main(){ int i,j,k,t,T,n,m,p; cin&gt;&gt;T; for(t=1;t&lt;=T;t++){ memset(a,0,sizeof a); cin&gt;&gt;n&gt;&gt;m&gt;&gt;p; for(i=1;i&lt;=n;i++) for(j=1;j&lt;=m;j++) cin&gt;&gt;a[i][j]; memset(s,0,sizeof s); for(i=1;i&lt;=n;i++) for(j=1;j&lt;=m;j++) s[i][j]=s[i][j-1]+a[i][j]; memset(w,0,sizeof w); for(i=1;i&lt;=p;i++) w[0][i]=-maxn; for(i=1;i&lt;=n;i++) for(j=1;j&lt;=p;j++){ int up=min(m,j); for(k=0;k&lt;=up;k++) if(w[i-1][j-k]+s[i][k]&gt;w[i][j]) w[i][j]=w[i-1][j-k]+s[i][k]; } printf(\"Case #%d: %d\\n\",t,w[n][p]); }} Problem 3 WorkoutProblemTambourine has prepared a fitness program so that she can become more fit! The program is made of N sessions. During the i-th session, Tambourine will exercise for Mi minutes. The number of minutes she exercises in each session are strictly increasing. The difficulty of her fitness program is equal to the maximum difference in the number of minutes between any two consecutive training sessions. To make her program less difficult, Tambourine has decided to add up to K additional training sessions to her fitness program. She can add these sessions anywhere in her fitness program, and exercise any positive integer number of minutes in each of them. After the additional training session are added, the number of minutes she exercises in each session must still be strictly increasing. What is the minimum difficulty possible? InputThe first line of the input gives the number of test cases, T. T test cases follow. Each test case begins with a line containing the two integers N and K. The second line contains N integers, the i-th of these is Mi, the number of minutes she will exercise in the i-th session. OutputFor each test case, output one line containing Case #x: y, where x is the test case number (starting from 1) and y is the minimum difficulty possible after up to K additional training sessions are added. LimitsTime limit: 20 seconds per test set.Memory limit: 1GB.1 ≤ T ≤ 100.For at most 10 test cases, 2 ≤ N ≤ 105.For all other test cases, 2 ≤ N ≤ 300.1 ≤ Mi ≤ 109.Mi &lt; Mi+1 for all i. Test set 1K = 1. Test set 21 ≤ K ≤ 105. 分析求间隔最大值的最小，典型的最大最小问题，二分思想。主要想法是二分枚举间隔x，通过check函数判断x是否能实现。假设最终的答案是t，那么x&lt; t时，checkout函数返回值为false，表示间隔到不了那么小，需要更多的K；x≥t时，check返回值为true，表示容忍的了那么大的间隔。因此该函数具有单调性，可以二分解决 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;#include&lt;math.h&gt;#include&lt;cstring&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;vector&gt;#include&lt;list&gt;#include&lt;map&gt;#include&lt;set&gt;#include&lt;string&gt;#include&lt;stack&gt;#include&lt;queue&gt;#include&lt;climits&gt;#include&lt;sstream&gt;#define maxn 100010using namespace std;int n,k;int a[maxn],d[maxn];bool check(int x){ int i,s=0; for(i=0;i&lt;n-1;i++) if(d[i]%x==0) s+=d[i]/x-1; else s+=d[i]/x; if(s&lt;=k) return true; return false;}int main(){ int i,j,T,t; cin&gt;&gt;T; for(t=1;t&lt;=T;t++){ memset(a,0,sizeof a); memset(d,0,sizeof d); cin&gt;&gt;n&gt;&gt;k; for(i=0;i&lt;n;i++) cin&gt;&gt;a[i]; for(i=0;i&lt;n-1;i++) d[i]=a[i+1]-a[i]; int l=1,r=1e9,mid,dl=0,dr=0; while(l&lt;r){ if(dl==l&amp;&amp;dr==r) break; dl=l;dr=r; mid=(l+r)/2; bool status=check(mid); if(status) r=mid; else l=mid+1; } printf(\"Case #%d: %d\\n\",t,(l+r)/2); }} Problem 4 BundlingProblemPip has N strings. Each string consists only of letters from A to Z. Pip would like to bundle their strings into groups of size K. Each string must belong to exactly one group. The score of a group is equal to the length of the longest prefix shared by all the strings in that group. For example:The group {RAINBOW, RANK, RANDOM, RANK} has a score of 2 (the longest prefix is ‘RA’).The group {FIRE, FIREBALL, FIREFIGHTER} has a score of 4 (the longest prefix is ‘FIRE’).The group {ALLOCATION, PLATE, WORKOUT, BUNDLING} has a score of 0 (the longest prefix is ‘’). Please help Pip bundle their strings into groups of size K, such that the sum of scores of the groups is maximized. InputThe first line of the input gives the number of test cases, T. T test cases follow. Each test case begins with a line containing the two integers N and K. Then, N lines follow, each containing one of Pip’s strings. OutputFor each test case, output one line containing Case #x: y, where x is the test case number (starting from 1) and y is the maximum sum of scores possible. LimitsTime limit: 20 seconds per test set.Memory limit: 1GB.1 ≤ T ≤ 100.2 ≤ N ≤ 105.2 ≤ K ≤ N.K divides N.Each of Pip’s strings contain at least one character.Each string consists only of letters from A to Z. Test set 1Each of Pip’s strings contain at most 5 characters. Test set 2The total number of characters in Pip’s strings across all test cases is at most 2 × 106. 分析据说是转化成字典树(Trie树)，暂时不会……","link":"/2020/03/27/Kickstart-Round-A-2020/"},{"title":"Vim","text":"为什么使用Vim 程序员编程不同于英语写作，大部分时间可能都在看代码和修改代码，一直在编辑的时间比较少，因此引入Vim工具。Vim本身通过character命令的方式进行文本编辑，当熟练之后可以大大提高程序编写速度。 Mode 存在几种基本模式：Normal Mode,Insert Mode,Command-line Mode,Viusal Mode Normal Mode–&gt;Insert Mode：i Back to Normal Mode:ESC Normal Mode–&gt;Command-line Mode: : Back to Normal Mode:ESC Noraml Mode–&gt;Viusal Mode: v Back to Normal Mode:ESC Replace Mode Movement-光标移动 Movements in Vim are also called “nouns”, because they refer to chunks of text. Basic movement: hjkl (left, down, up, right) Words: w (next word), b (beginning of word), e (end of word) Lines: 0 (beginning of line), ^ (first non-blank character), $ (end of line) Screen: H (top of screen), M (middle of screen), L (bottom of screen) Scroll: Ctrl-u (up), Ctrl-d (down) File: gg (beginning of file), G (end of file) Line numbers: :{number} or {number}G (line {number}) Misc: % (corresponding item) Find: f{character}, t{character}, F{character}, T{character} find/to forward/backward {character} on the current line , / ; for navigating matches Search: /{regex}, n / N for navigating matches h/j/k/l:上下左右移动 nj:光标向下移动多行 0：行首 =”Home” Key $：行尾 =”End” Key Ctrl+f =”Page Down” Key Ctrl+b =”Page Up” Key e:下一个单次结尾字符 b：与e相反 w:跳转到下一个单次 o:open在当前行下面添加一行 Viusal Modev:Viusal Mode 普通选中 V: 选中多行 Ctrl+v:Visual Block 选中一个矩形区域 Edits Vim’s editing commands are also called “verbs”, because verbs act on nouns. i enter insert mode but for manipulating/deleting text, want to use something more than backspace o / O insert line below / above d{motion} delete {motion} e.g. dw is delete word, d$ is delete to end of line, d0 is delete to beginning of line c{motion} change {motion} e.g. cw is change word like d{motion} followed by i x delete character (equal do dl) s substitute character (equal to xi) visual mode + manipulation select text, d to delete it or c to change it u to undo, to redo y to copy / “yank” (some other commands like d also copy) p to pasteLots more to learn: e.g. ~ flips the case of a character 删除x:删除当前字符dw:删除当前单词dnw:删除n个单词 dd:删除光标所在行ndd:删除光标以下n行d1G:删除第一行到本行所有内容dG:删除本行到结尾所有内容 d0:删除光标到本行开始内容d$:删除光标到本行结束的位置 选中块删除:visual模式 复制yy:nyy:y1G:yG: y0:yG: 选中块复制：进入Visual模式后 y 粘贴p 剪切cj:剪切一行cw:剪切一个单词 选中块剪切:Visual Mode 查找/word:向下查找?word:向上查找n:下一个N:上一个 替换(Command Mode):%s/word1/word2/g 全文替换:n1,n2s/wordl/word2/g n1到n2行间查找替换 撤销u:Undoctrl+r: Redo Counts You can combine nouns and verbs with a count, which will perform a given action a number of times. 3w move 3 words forward 5j move 5 lines down 7dw delete 7 words Modifiers(括号、引号等) Some modifiers are i, which means “inner” or “inside”, and a, which means “around”. d%:删除括号内所有内容ci[ ：剪切[]内容ci( : 剪切()内容da’:删除’’内所用内容,包括引号本身 [hello world](open a window hello) ReferenceMIT Vim Lessons Add MasterXuBoya’s file","link":"/2020/03/18/Vim/"},{"title":"资源素材库","text":"图片库Gallery 芝加哥大学博物馆世界名画https://www.artic.edu/collection wiki commons(https://commons.wikimedia.org/wiki/Main_Page)方法：搜索”画家名+google art project” CCSearchhttps://search.creativecommons.org/ pexelshttps://www.pexels.com/ creativecommonshttps://creativecommons.org/ 小图标制作工具 font_awesome(html图标)https://www.thinkcmf.com/font/font_awesome/icon/user-circle 阿里巴巴矢量图库https://www.iconfont.cn/ 在线favicon图库(可编辑)https://favicon.io/emoji-favicons/unicorn-face/ 在线svg制作logo工具(可载入图标编辑)https://svg.wxeditor.com/ Hexo博客资源库Icarus主题基本配置及美化官方文档：https://blog.zhangruipeng.me/hexo-theme-icarus/https://dp2px.com/ 该作者的GitHub源码：https://github.com/lxqxsyu/hexo-theme-icarushttps://removeif.github.io/ 该作者的GitHub源码：https://github.com/removeif/hexo-theme-icarus-removeifhttps://www.ccyh.xyz/https://www.alphalxy.com// Next主题基本配置及美化官方文档：https://theme-next.org/docs/https://blog.zhengyujie.cn/http://saili.science/comments/https://guanqr.com/https://www.itrhx.com/2018/08/27/A04-Hexo-blog-topic-personalization/http://yearito.cn/about/https://guanqr.com/tech/website/hexo-theme-next-customization/#%E6%A0%87%E7%AD%BE%E9%A1%B5%E9%9D%A2 博客推广博客推广及谷歌搜索优化利用GitBook制作电子书，发布于网络并绑定个性域名","link":"/2020/03/02/%E8%B5%84%E6%BA%90%E7%B4%A0%E6%9D%90%E5%BA%93/"},{"title":"计算机网络","text":"计算机网络概述计算机网络=通信技术+计算机技术 计算机协议：类比交通系统，仅有道路还不行，还需要各种交通规则(协议)，否则很容易出现拥堵或故障 协议三要素： 语法Syntax 语义Semantics 时序 协议的官方文档：RFC: Request for Comments 网络由以下几部分组成： 网络边缘 接入网络，物理介质 网络核心(互联的路由器) 网络边缘(端)的两种通信模型 client/server：web应用、FTP等 P2P(对等模型)：QQ、Skype等 接入网络的方式： DSL/ADSL（家庭上网） 利用已有的电话线路，数据通过电话线接入Internet，语音通过DSL电话线接入电话网 电缆网络（家庭上网） 和家用有线电视共用线路 以太网（Ethernet） 公司、高校、企业 无线局域网Wifi 移动蜂窝网 网络核心：路由（routing）+转发（forward） ​ 计算机网络结构和道路系统很像,一级ISP相当于国道，在地图上用很粗的线表示，连接各个省份之间。二级ISP相当于省道，贯穿于各市。所有的端设备通过“小路”连入互联网，可以达到全世界任意的地方。 数据交换技术 电路交换 电路交换主要用于电话系统，最典型的特征是独占资源，每条通话需要专门的数据链路 电路交换的三个阶段： 建立连接（呼叫/电路建立） 通信 释放连接（拆除电路） 电路交换网络的链路共享——多路复用技术 ​ 每路呼叫独占分配到的资源片进行通信,比如说电话系统，采用频分多路复用后，分配给某条线路的频段就是固定的，别人无法抢占。 ​ 资源片可能“闲置”(idle)，如电话系统无人说话，但是此频段依然占据 频分多路复用( frequencydivision multiplexing-FDM ) 频分多路复用的各用户占用不同的带宽资源，用户在分配到一定的频带后，在通信过程中自始至终都占用这个频带 时分多路复用( time divisionmultiplexing-TDM ) 时分复用则是将时间划分为一段段等长的时分复用帧（TDM 帧），每个用户在每个 TDM 帧中占用固定序号的时隙。时分复用的所有用户是在不同的时间占用相同的频带宽度 波分多路复用(Wavelengthdivision multiplexing-WDM) 波分复用就是光的频分复用 码分多路复用( Codedivision multiplexing-CDM ) 各用户使用相同频率载波，利用各自码片序列编码数据。传输过程输出的数据是各信号编码信号的叠加 编码信号 = (原始数据) × (码片序列) 解码 : 码片序列与编码信号的内积 各用户码片序列相互正交(orthogonal) 报文交换/分组交换 ​ 分组交换是一种特殊的报文交换，将报文拆分成一个一个很小的分组，加入“分组头”后进行传输。因此分组交换需要报文的拆分与重组 统计多路复用 ​ 如上图所示，多条道路既不复用频段，也不复用时段。对于某个路由器而言，他只负责存储-转发，报文中包含着目的地信息。 + 报文交换以完整报文进行“存储-转发” + 分组交换以较小的分组进行“存储-转发”分组交换的报文交付时间（仅考虑传输延迟） 总的传输时间T等于所有的报文M发送的时间，加上最后一个分组L经过n次路由的时间 性能对比 分组交换vs报文交换 降低数据链路传输时间，分组交换类似流水线，存在并行传输过程 每个路由器的缓存容量要求小，L&lt;&lt;M 电路交换vs分组交换 分组交换允许更多用户同时使用网络 分组交换适用于突发数据传输网络（上网过程并不是一直在网络传输，用户的网络平均活动时间一般仅占10%，很多时间用户上网并不涉及到数据的上传和下载，而是在浏览下载好的页面） 可能产生拥塞现象，造成分组延迟和丢失 专业术语丢包：分组在路由器排队，分组到达速率超出输出链路容量时 四种分组延迟 结点处理延迟（通常&lt; msec，很多场景可忽略） 差错检测 确定输出链路 排队延迟（很难界定） 等待输出链路可用 取决于路由器拥塞程度 传输延迟（发送分组需要的时间） L: 分组长度(bits) R: 链路带宽 (bps) $$d_{trans}=L/R$$ 传播延迟（线路上消耗时间） d: 物理链路长度 s: 信号传播速度 (~2×10^8m/sec) $$d_{prop}=d/s$$ 吞吐量/率——Throughput 吞吐量 :表示在发送端与接收端之间传送数据速率 (b/s) 端到端路径的吞吐量取决于瓶颈链路的速率（最小链路） 计算机网络体系结构概览网络体系结构是从功能上描述计算机网络结构 分层结构的优点 结构清晰，有利于识别复杂系统的部件及其关系分层的参考模型（reference model ） 模块化的分层易于系统更新、维护 任何一层服务实现的改变对于系统其它层都是透明的 有利于标准化 分层结构的缺点 分层过多可能会导致效率低下","link":"/2020/04/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"},{"title":"软件工程导论","text":"常见软件生存周期模型瀑布模型系统需求–&gt;软件需求–&gt;需求分析–&gt;设计–&gt;编码–&gt;测试–&gt;运行 流式，每个环节是前一个环节的输出，是下一个环节的输入 存在闭环，可能存在返工 缺点： 客户必须完整正确表达需求，开发人员必须一开始理解需求 划分过细，文档过多 增量模型需求方如果不能一下确定所有需求，先选择最重要的确定性需求进行开发，后续不断添加新的需求（增量） 优点： 第一个可交付版本成本和时间很小 开发每个增量的软件风险小 实现对用户需求变更的制约，需求方对于当前的版本验收肯定之后，不可随意变更需求 缺点： 管理的成本复杂性高 演化模型有一些小的开发步组成，每一步需要历经需求分析、设计、实现和验证。 最开始需求不明确，试探性的开发。不是增量式，而是一种全新的开发 喷泉模型迭代 无缝 面向对象方法","link":"/2020/04/02/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E5%AF%BC%E8%AE%BA/"},{"title":"操作系统","text":"进程与线程内存管理I/O设备管理磁盘管理 磁盘的五层抽象 第一层抽象：block–&gt;CHS​ 磁盘I/O的时间主要浪费在寻道上，而用户时间在工作时，通常需要访问block连续的区间，因此对磁盘编码的主要工作着眼点就是尽量降低寻道时间。磁盘有三个维度，也就是说存在多种编码方式，最优的编码方式按照如下顺序依次编码： 磁道：对扇区编码时，1号扇区在0号扇区的同一磁道，旋转磁盘，直至同一磁道填满； 柱面：然后对同一个柱面的不同磁道编码，和上面类似的过程； 磁头：移动磁头到不同的柱面，重复上述两个过程。 block= C × (Heads× Sectors) + H× Sectors + S ​ 通常block包含多个扇区，block是逻辑的磁盘块，而扇区是物理的磁盘块。block是上层应用所能访问的最小磁盘块，block越大读取的速度也就越大，但是空间利用率就会有所下降；反之亦然。 第二层抽象 ：多个block并发 磁盘只要一个，但是会存在多个进程访问磁盘，因此需要建立队列。 最简单的调度方式就是采用FIFO SSTF 磁盘调度：该方法每次访问离当前位置最近的磁盘块。由于实际系统的磁盘调用大多集中在中部位置，因此两遍的磁盘块可能存在”饥饿现象“，进入队列很久都无法访问。 SCAN 磁盘调度：从当前位置一直向左，再一直向右，再一直向左…… 电梯调度算法：每次从最后边向左访问，然后复位到最后侧（该操作速度很快），重新从最大的位置往左依次访问。 第三层抽象File：inode–&gt;block ​ 一个文件在磁盘中会分布到多个block，每一个文件存在一个FCB（文件描述符）， 该结构记录了文件的逻辑块与物理block之间的映射关系。 顺序存储方式 文件的多个block在磁盘上是依次存储的，该方式不适合数据文件的动态变化； 链式存储方式 链式存储方式在每次block记录下一个block存储的位置。最大的确实是无法“定位”，访问第10个block必须依次访问前9个 索引存储方式 索引存储方式类似map，也就是我们通常思维的实现方式，将逻辑的块与物理的block映射起来 多级索引 ​ 多级索引的结构如上图所示，该struct其实是记录在inode结构，也就是在FCB中。inode-&gt;i_zone前7个通过直接索引得到。inode-&gt;i_zone[7]指向的block块是一个索引结构，该block块建立了逻辑块与索引块的映射关系。进一步地，还有二级索引、三级索引。 12345678int _bmap(m_inode *inode, int block, int create) { if(block&lt;7){ if(create&amp;&amp;!inode-&gt;i_zone[block]) { inode-&gt;i_zone[block]=new_block(inode-&gt;i_dev); inode-&gt;i_ctime=CURRENT_TIME; inode-&gt;i_dirt=1;} return inode-&gt;i_zone[block];} block-=7; if(block&lt;512){ bh=bread(inode-&gt;i_dev,inode-&gt;i_zone[7]); return (bh-&gt;b_data)[block];} ... 第四层抽象目录:path–&gt;inode 如何通过/my/data/a这个目录得到文件的inode是本层抽象所要解决的问题 ​ 所有文件、目录的FCB统一放在磁盘的某一段连续空间，并按顺序编号。我们平时C语言open函数得到的fd其实就是FCB数组的index，利用FCB[fd]就可以得到该文件的inode信息，进而访问该文件的数据。 ​ 根目录/默认在FCB数组的起始位置，按照文件的目录结构依次解析。首先访问/获取根目录的inode，此时可以读取根目录的data，根目录的数据内容就是&lt;var,13&gt;&lt;my,82&gt;这种信息。读取根目录的内容就可以得到my所在的fd，进而可以访问FCB数组的82号位置，得到my的inode，进而读取my的数据内容。不断重复上述过程，直至解析到叶子文件。此时就可以调用file的操作了。 ​ 为了实现磁盘的自动检测，所有磁盘的配置信息、基本参数还是存在磁盘中。总体来看，磁盘首先是引导块（一般占据一个block），然后是超级快（super），超级快存储了接下来两个块的长度，有了这两块的长度，程序就可以 快速定位根目录/所在的FCB块。 总结","link":"/2020/05/30/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"}],"tags":[{"name":"编程语言","slug":"编程语言","link":"/tags/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"},{"name":"Golang","slug":"Golang","link":"/tags/Golang/"},{"name":"Gin","slug":"Gin","link":"/tags/Gin/"},{"name":"gRPC","slug":"gRPC","link":"/tags/gRPC/"},{"name":"Docker","slug":"Docker","link":"/tags/Docker/"},{"name":"Hexo","slug":"Hexo","link":"/tags/Hexo/"},{"name":"Icarus","slug":"Icarus","link":"/tags/Icarus/"},{"name":"Next","slug":"Next","link":"/tags/Next/"},{"name":"Git","slug":"Git","link":"/tags/Git/"},{"name":"Github","slug":"Github","link":"/tags/Github/"},{"name":"VPS","slug":"VPS","link":"/tags/VPS/"},{"name":"GitHub","slug":"GitHub","link":"/tags/GitHub/"},{"name":"基础知识","slug":"基础知识","link":"/tags/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"},{"name":"数据库","slug":"数据库","link":"/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"name":"Markdown","slug":"Markdown","link":"/tags/Markdown/"},{"name":"Kickstart","slug":"Kickstart","link":"/tags/Kickstart/"},{"name":"OJ","slug":"OJ","link":"/tags/OJ/"},{"name":"Vim","slug":"Vim","link":"/tags/Vim/"},{"name":"Linux","slug":"Linux","link":"/tags/Linux/"},{"name":"软件工程","slug":"软件工程","link":"/tags/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/"},{"name":"大数据","slug":"大数据","link":"/tags/%E5%A4%A7%E6%95%B0%E6%8D%AE/"},{"name":"Hbase","slug":"Hbase","link":"/tags/Hbase/"},{"name":"HDFS","slug":"HDFS","link":"/tags/HDFS/"},{"name":"MapReduce","slug":"MapReduce","link":"/tags/MapReduce/"},{"name":"SQL","slug":"SQL","link":"/tags/SQL/"},{"name":"计算机网络","slug":"计算机网络","link":"/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"},{"name":"TCP/IP","slug":"TCP-IP","link":"/tags/TCP-IP/"},{"name":"操作系统","slug":"操作系统","link":"/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"}],"categories":[{"name":"编程语言","slug":"编程语言","link":"/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"},{"name":"工具","slug":"工具","link":"/categories/%E5%B7%A5%E5%85%B7/"},{"name":"个人网站","slug":"个人网站","link":"/categories/%E4%B8%AA%E4%BA%BA%E7%BD%91%E7%AB%99/"},{"name":"Golang","slug":"编程语言/Golang","link":"/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Golang/"},{"name":"Docker","slug":"工具/Docker","link":"/categories/%E5%B7%A5%E5%85%B7/Docker/"},{"name":"基础知识","slug":"基础知识","link":"/categories/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"},{"name":"Hexo","slug":"个人网站/Hexo","link":"/categories/%E4%B8%AA%E4%BA%BA%E7%BD%91%E7%AB%99/Hexo/"},{"name":"Markdown","slug":"编程语言/Markdown","link":"/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Markdown/"},{"name":"数据结构与算法","slug":"数据结构与算法","link":"/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"},{"name":"Vim","slug":"工具/Vim","link":"/categories/%E5%B7%A5%E5%85%B7/Vim/"},{"name":"Git","slug":"工具/Git","link":"/categories/%E5%B7%A5%E5%85%B7/Git/"},{"name":"数据库","slug":"基础知识/数据库","link":"/categories/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"name":"Kickstart","slug":"数据结构与算法/Kickstart","link":"/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/Kickstart/"},{"name":"软件工程","slug":"基础知识/软件工程","link":"/categories/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/"},{"name":"大数据","slug":"基础知识/大数据","link":"/categories/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/%E5%A4%A7%E6%95%B0%E6%8D%AE/"},{"name":"计算机网络","slug":"基础知识/计算机网络","link":"/categories/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"},{"name":"操作系统","slug":"基础知识/操作系统","link":"/categories/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"}]}